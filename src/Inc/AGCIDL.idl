/////////////////////////////////////////////////////////////////////////////
// AGCIDL.idl : IDL source for interfaces used by AGC.dll
//
// This file will be processed by the MIDL tool to
// produce the type library (AGC.tlb) and marshalling code.

// Disable the annoying warning about needing NT 4.0 SP3 or greater
midl_pragma warning(disable:2362)

import "oaidl.idl";
import "ocidl.idl";


/////////////////////////////////////////////////////////////////////////////
// Forward Declarartions
//
enum AGCObjectType;
enum AGCHullAbility;
enum AGCAxis;
enum AGCEquipmentType;
enum AGCTreasureType;
enum AGCChatTarget;
enum AGCEventID;
enum FileAttributes;

interface IAGCEventSink;
interface IAGCEventSinkSynchronous;
interface IAGCDebugHook;
interface IAGCGlobal;
interface IAGCVector;
interface IAGCVectorPrivate;
interface IAGCOrientation;
interface IAGCOrientationPrivate;
interface IAGCEvent;
interface IAGCEventCreate;
interface IAGCGameParameters;
interface IAGCCommand;
interface IAGCCommandPrivate;
interface IAGCVersionInfo;
interface IAGCDBParams;
interface IAGCEventLogger;
interface IAGCEventLoggerHook;
interface IAGCEventLoggerPrivate;
interface IAGCRangePrivate;
interface IAGCRangesPrivate;
interface IAGCEventIDRange;
interface IAGCEventIDRanges;
interface ITCCollection;
interface ITCStrings;
interface ITCPropBagOnRegKey;
interface ITCSessionInfo;
interface ITCSessionInfos;
interface ITCCollectionPersistHelper;
interface ITCUtility;
interface IAdminSessionHelper;

interface IAGCPrivate;
interface IAGCCommon;
interface IAGCCollection;
interface IAGCBase;  // "base" as in "base class", not to be confused with Station
interface IAGCModel;
interface IAGCModels;
interface IAGCBuyable;
interface IAGCHullType;
//interface IAGCHullTypes;
interface IAGCTreasure;
interface IAGCTreasures;
interface IAGCDamage;
interface IAGCScanner;
interface IAGCProbe;
interface IAGCProbes;
interface IAGCGame;
interface IAGCShip;
interface IAGCShips;
interface IAGCStation;
interface IAGCStations;
interface IAGCAleph;
interface IAGCAlephs;
interface IAGCSector;
interface IAGCSectors;
interface IAGCTeam;
interface IAGCTeams;
interface IAGCAsteroid;
interface IAGCAsteroids;


/////////////////////////////////////////////////////////////////////////////
// {secret}
// DISPID Enumeration
//
enum dispid_AGCIDL
{
  dispid_AGCIDL_Begin = 100,
  dispid_Description = dispid_AGCIDL_Begin,

  // AGCBase
  dispid_ObjectType,
  dispid_ObjectID,
  dispid_UniqueID = 9999,
  dispid_GetMission = dispid_ObjectID + 1,
  dispid_BaseUniqueID,

  dispid_Price,
  dispid_TimeToBuild,
  dispid_Type,
  dispid_Amount,
  dispid_Buyable,
  dispid_Orientation,
  dispid_Rotation,
  dispid_Radius,
  dispid_Team,
  dispid_Mass,
  dispid_Sector,
  dispid_Signature,
  dispid_ModelName,
  dispid_IsSelectable,
  dispid_IsScanner,
  dispid_IsPredictable,
  dispid_IsScanRequired,
  dispid_IsStatic,
  dispid_IsDamagable,
  dispid_IsHitable,

  dispid_IsVisible,
  dispid_IsSeenBySide,
  dispid_Position,
  dispid_Velocity,

  dispid_Fraction,
  dispid_InScannerRange,
  dispid_CanSee,

  dispid_VectorX,
  dispid_VectorY,
  dispid_VectorZ,
  dispid_VectorDisplayString,

  dispid_Target,
  dispid_Verb,

  dispid_Length,
  dispid_MaxSpeed,
  dispid_MaxTurnRate,
  dispid_TurnTorque,
  dispid_Thrust,
  dispid_SideMultiplier,
  dispid_BackMultiplier,
  dispid_ScannerRange,
  dispid_MaxEnergy,
  dispid_RechargeRate,
  dispid_HitPoints,
  dispid_PartMask,
  dispid_MaxWeapons,
  dispid_MaxFixedWeapons,
  dispid_CanMount,
  dispid_Capabilities,
  dispid_HasCapability,
  dispid_MaxAmmo,
  dispid_MaxFuel,
  dispid_AutoDonate,
  dispid_ShieldFraction,
  dispid_UserName,
  dispid_ComputerName,
  dispid_ApplicationName,
  dispid_TimeCreated,
  dispid_Duration,
  dispid_Cookie,
  dispid_Collection1,
  dispid_Collection2,
  dispid_Collection3,
  dispid_Collection4,
  dispid_Collection5,
  dispid_Collection6,
  dispid_Collection7,
  dispid_Collection8,
  dispid_Ammo,
  dispid_Fuel,
  dispid_Energy,
  dispid_WingID,
  dispid_HullType,
  dispid_BaseHullType,
  dispid_ProjectileType,
  dispid_EmissionPoint,
  dispid_Lifespan,
  dispid_DtBurst,
  dispid_Accuracy,
  dispid_IsRipcord,
  dispid_Stations,
  dispid_Ships,
  dispid_Alephs,
  dispid_Asteroids,
  dispid_ScreenX,
  dispid_ScreenY,
  dispid_Probes,
  dispid_Sectors,
  dispid_Teams,
  dispid_LookupShip,
  dispid_GameParameters,
  dispid_GameID,
  dispid_LookupTeam,
  dispid_GameStage,
  dispid_Civ,
  dispid_Buoys,
  dispid_Models,
  dispid_SelectableModels,
  dispid_Treasures,
  dispid_Mines,
  dispid_Missiles,
  dispid_ReplayCount,
  dispid_ContextName,

  dispid_AGCIDL_End = dispid_AGCIDL_Begin + 0x1000
};


/////////////////////////////////////////////////////////////////////////////
[
  uuid(15F770CE-1553-11d3-8B60-00C04F681633),
  helpstring("AGCUniqueID type.")
]
typedef long AGCUniqueID;


/////////////////////////////////////////////////////////////////////////////
[
  uuid(3CF30DBA-F949-11d2-A50F-00C04F68DEB0),
  helpstring("AGCObjectID type.")
]
typedef short AGCObjectID;  // IGC's ObjectID


/////////////////////////////////////////////////////////////////////////////
[
  uuid(2F1CF66E-2A97-11d3-8B66-00C04F681633),
  helpstring("AGCGameID type.")
]
typedef long AGCGameID;     // IGC's MissionID



/////////////////////////////////////////////////////////////////////////////
[
  uuid(E4A8B1CA-F8FB-11d2-A50F-00C04F68DEB0),
  helpstring("AGCMoney type.")
]
typedef long AGCMoney;      // IGC's Money


/////////////////////////////////////////////////////////////////////////////
[
  uuid(2F31471C-F8E4-11d2-A50F-00C04F68DEB0),
  helpstring("AGCHitPoints type.")
]
typedef short AGCHitPoints; // IGC's HitPoints


/////////////////////////////////////////////////////////////////////////////
[
  uuid(3581C176-F8E4-11d2-A50F-00C04F68DEB0),
  helpstring("AGCPartMask type.")
]
typedef unsigned char AGCPartMask;   // IGC's PartMask


/////////////////////////////////////////////////////////////////////////////
[
  uuid(3581C177-F8E4-11d2-A50F-00C04F68DEB0),
  helpstring("AGCMount type.")
]
typedef char AGCMount;      // IGC's Mount


/////////////////////////////////////////////////////////////////////////////
[
  uuid(267D0FE4-F8E6-11d2-A50F-00C04F68DEB0),
  helpstring("AGCHullAbilityBitMask type.")
]
typedef short AGCHullAbilityBitMask;      // IGC's HullAbilityBitMask


/////////////////////////////////////////////////////////////////////////////
[
  uuid(BA3A5628-38B6-11d3-A51D-00C04F68DEB0),
  helpstring("AGCAsteroidAbilityBitMask type.")
]
typedef short AGCAsteroidAbilityBitMask;  // IGC's AsteroidAbilityBitMask


/////////////////////////////////////////////////////////////////////////////
[
  uuid(CF19DD9A-33D9-11d3-A51C-00C04F68DEB0),
  helpstring("AGCSoundID type.")
]
typedef short AGCSoundID;                 // IGC's SoundID


/////////////////////////////////////////////////////////////////////////////
// Be sure to keep these in sync with the actual ones in <igc.h>
[
  uuid(7E81D620-F94A-11d2-A50F-00C04F68DEB0),
  helpstring("Constants for AGCObjectType.")
]
typedef [v1_enum] enum AGCObjectType      // IGC's ObjectType
{
  AGCObjectType_Invalid = -1,             // IGC's OT_invalid

  AGC_ModelBegin       =  0,              // IGC's OT_modelBegin
    AGC_Ship           =  0,              // IGC's   OT_ship
    AGC_Station        =  1,              // IGC's   OT_station
    AGC_Missile        =  2,              // IGC's   OT_missile
    AGC_Mine           =  3,              // IGC's   OT_mine
    AGC_Probe          =  4,              // IGC's   OT_probe
    AGC_Asteroid       =  5,              // IGC's   OT_asteroid
    AGC_Projectile     =  6,              // IGC's   OT_projectile
    AGC_Warp           =  7,              // IGC's   OT_warp
    AGC_Treasure       =  8,              // IGC's   OT_treasure
    AGC_Buoy           =  9,              // IGC's   OT_buoy
    AGC_Chaff          = 10,              // IGC's   OT_chaff
    AGC_BuildingEffect = 11,              // IGC's   OT_buildingEffect
  AGC_ModelEnd         = 11,              // IGC's OT_modelEnd

  AGC_Side             = 12,              // IGC's OT_side
  AGC_Cluster          = 13,              // IGC's OT_cluster
  AGC_Bucket           = 14,              // IGC's OT_bucket

  AGC_PartBegin        = 15,              // IGC's OT_partBegin
    AGC_Weapon         = 15,              // IGC's   OT_weapon
    AGC_Shield         = 16,              // IGC's   OT_shield
    AGC_Cloak          = 17,              // IGC's   OT_cloak
    AGC_Pack           = 18,              // IGC's   OT_pack
    AGC_Afterburner    = 19,              // IGC's   OT_afterburner
    AGC_LauncherBegin  = 20,              // IGC's   OT_launcherBegin
      AGC_Magazine     = 20,              // IGC's     OT_magazine
      AGC_Dispenser    = 21,              // IGC's     OT_dispenser
    AGC_LauncherEnd    = 21,              // IGC's   OT_launcherEnd
  AGC_PartEnd          = 21,              // IGC's OT_partEnd

  AGC_StaticBegin      = 22,              // IGC's OT_staticBegin
    AGC_ProjectileType = 22,              // IGC's   OT_projectileType
    AGC_MissileType    = 23,              // IGC's   OT_missileType
    AGC_MineType       = 24,              // IGC's   OT_mineType
    AGC_ProbeType      = 25,              // IGC's   OT_probeType
    AGC_ChaffType      = 36,              // IGC's   OT_chaffType
    AGC_Civilization   = 27,              // IGC's   OT_civilization
    AGC_TreasureSet    = 28,              // IGC's   OT_treasureSet

    AGC_BucketStart    = 29,              // IGC;s   OT_bucketStart
      AGC_HullType     = 29,              // IGC's     OT_hullType
      AGC_PartType     = 30,              // IGC's     OT_partType
      AGC_StationType  = 31,              // IGC's     OT_stationType
      AGC_Development  = 32,              // IGC's     OT_development
      AGC_DroneType    = 33,              // IGC's     OT_droneType
    AGC_BucketEnd      = 33,              // IGC's   OT_bucketEnd
  AGC_StaticEnd        = 33,              // IGC's OT_staticEnd
  
  AGC_Constants        = 34,              // IGC's OT_constants
  AGC_AdminUser        = 35,              // IGC's OT_allsrvUser
  AGCObjectType_Max    = 36,              // IGC's OT_Max
  AGC_Any_Objects      = 36 // should be equal to or greater than max, but less than 256

} AGCObjectType;

/////////////////////////////////////////////////////////////////////////////
[
  uuid(5C756B32-F8E6-11d2-A50F-00C04F68DEB0),
  helpstring("Constants for the AGCHullAbilityBitMask type.")
]
typedef [v1_enum] enum AGCHullAbility     // IGC's HullAbilityBitMask
{
  AGCHullAbility_Board       = 0x01 ,     // IGC's c_habmBoard
  AGCHullAbility_Rescue      = 0x02 ,     // IGC's c_habmRescue
  AGCHullAbility_Lifepod     = 0x04 ,     // IGC's c_habmLifepod
  AGCHullAbility_NoPickup    = 0x08 ,     // IGC's c_habmNoPickup
  AGCHullAbility_NoEjection  = 0x10 ,     // IGC's c_habmNoEjection
  AGCHullAbility_NoRipcord   = 0x20 ,     // IGC's c_habmNoRipcord
  AGCHullAbility_CheatToDock = 0x40 ,     // IGC's c_habmCheatToDock
  AGCHullAbility_Fighter     = 0x80 ,     // IGC's c_habmFighter
  AGCHullAbility_Captital    = 0x100,     // IGC's c_habmCapital
} AGCHullAbility;


/////////////////////////////////////////////////////////////////////////////
[
  uuid(349CEC0A-38B7-11d3-A51D-00C04F68DEB0),
  helpstring("Constants for the AGCAsteroidAbilityBitMask type.")
]
typedef [v1_enum] enum AGCAsteroidAbility // IGC's AsteroidAbilityBitMask
{
  AGCAsteroidAbility_MineHe3   = 0x01,    // IGC's c_aabmMineHe3   - Has minable ore of Helium (all mutually exclusive)
  AGCAsteroidAbility_MineIce   = 0x02,    // IGC's c_aabmMineIce   - Has minable ore of Ice    (all mutually exclusive)
  AGCAsteroidAbility_MineGold  = 0x04,    // IGC's c_aabmMineGold  - Has minable ore of Golb   (all mutually exclusive)
  AGCAsteroidAbility_Buildable = 0x08,    // IGC's c_aabmBuildable - Buildings can be built on it
  AGCAsteroidAbility_Special   = 0x10,    // IGC's c_aabmSpecial   - Special buildings can be built on it
} AGCAsteroidAbility;


/////////////////////////////////////////////////////////////////////////////
[
  uuid(30B2A0F4-F8E7-11d2-A50F-00C04F68DEB0),
  helpstring("Constants for AGCAxis.")
]
typedef [v1_enum] enum AGCAxis            // IGC's Axis
{
  AGCAxis_Yaw      = 0,                   // IGC's c_axisYaw
  AGCAxis_Pitch    = 1,                   // IGC's c_axisPitch
  AGCAxis_Roll     = 2,                   // IGC's c_axisRoll
  AGCAxis_Throttle = 3,                   // IGC's c_axisThrottle
  AGCAxis_Max      = 4,                   // IGC's c_axisMax
} AGCAxis;


/////////////////////////////////////////////////////////////////////////////
[
  uuid(DFB0FB10-F8E6-11d2-A50F-00C04F68DEB0),
  helpstring("Constants for AGCEquipmentType.")
]
typedef [v1_enum] enum AGCEquipmentType   // IGC's EquipmentType
{
  AGCEquipmentType_ChaffLauncher = 0,     // IGC's ET_ChaffLauncher
  AGCEquipmentType_Weapon        = 1,     // IGC's ET_Weapon
  AGCEquipmentType_Magazine      = 2,     // IGC's ET_Magazine
  AGCEquipmentType_Dispenser     = 3,     // IGC's ET_Dispenser
  AGCEquipmentType_Shield        = 4,     // IGC's ET_Shield
  AGCEquipmentType_Cloak         = 5,     // IGC's ET_Cloak
  AGCEquipmentType_Pack          = 6,     // IGC's ET_Pack
  AGCEquipmentType_Afterburner   = 7,     // IGC's ET_Afterburner
  AGCEquipmentType_MAX           = 8,     // IGC's ET_MAX
} AGCEquipmentType;


/////////////////////////////////////////////////////////////////////////////
// Be sure to keep thes in sync with the actual ones in <igc.h>
[
  uuid(33505004-0E49-11d3-8B59-00C04F681633),
  helpstring("Constants for AGCTreasureType.")
]
typedef [v1_enum] enum AGCTreasureType    // IGC's TreasureCode
{
  AGCTreasureType_Part        = 0,        // IGC's c_tcPart
  AGCTreasureType_Development = 1,        // IGC's c_tcDevelopment
} AGCTreasureType;


/////////////////////////////////////////////////////////////////////////////
// Be sure to keep thes in sync with the actual ones in <igc.h>
[
  uuid(3AF8F031-08B2-44af-B12E-F7DBA94B800D),
  helpstring("Constants for AGCChatTarget.")
]
typedef [v1_enum] enum AGCChatTarget      // IGC's ChatTarget
{
  AGCChat_Everyone = 0,                   // IGC's CHAT_EVERYONE
  AGCChat_Allies,						  // IGC's CHAT_ALLIES ALLY -imago 7/3/09
  AGCChat_Leaders,                        // IGC's CHAT_LEADERS
  AGCChat_Admin,                          // IGC's CHAT_ADMIN
  AGCChat_Ship,                           // IGC's CHAT_SHIP
  // These require objectID to be set
  AGCChat_Team,                           // IGC's CHAT_TEAM
  AGCChat_Individual,                     // IGC's CHAT_INDIVIDUAL
  AGCChat_Individual_NoFilter,            // IGC's CHAT_INDIVIDUAL_NOFILTER
  AGCChat_Wing,                           // IGC's CHAT_WING
  AGCChat_Echo,                           // IGC's CHAT_ECHO
  AGCChat_AllSector,                      // IGC's CHAT_ALL_SECTOR
  AGCChat_FriendlySector,                 // IGC's CHAT_FRIENDLY_SECTOR
  // These are client only ... get translated into multiple sends
  AGCChat_Group,                          // IGC's CHAT_GROUP
  AGCChat_GroupNoEcho,                    // IGC's CHAT_GROUP_NOECHO
  // Misc
  AGCChat_NoSelection,                    // IGC's CHAT_NOSELECTION
  AGCChat_Max,                            // IGC's CHAT_MAX
} AGCChatTarget;


/////////////////////////////////////////////////////////////////////////////
// Be sure to keep thes in sync with the actual ones in <igc.h>
[
  uuid(98C30026-8936-492d-9CAD-BEC2D046B9ED),
  helpstring("Constants for AGCGameStage.")
]
typedef [v1_enum] enum AGCGameStage    // IGC's STAGE
{
  AGCGameStage_NotStarted  = 0,     // IGC's STAGE_NOTSTARTED
  AGCGameStage_Starting    = 1,     // IGC's STAGE_STARTING
  AGCGameStage_Started     = 2,     // IGC's STAGE_STARTED
  AGCGameStage_Over        = 3,     // IGC's STAGE_OVER
  AGCGameStage_Terminate   = 4,     // IGC's STAGE_TERMINATE
} AGCGameStage;


/////////////////////////////////////////////////////////////////////////////
// FileAttributes Enumeration
[
  uuid(2942EC80-D0DC-11d2-9646-00C04F68DEB0),
  helpstring("Constants for file attributes.")
]
typedef [v1_enum] enum FileAttributes
{
  FileAttribute_None              = 0x00000000,
  FileAttribute_ReadOnly          = 0x00000001,
  FileAttribute_Hidden            = 0x00000002,
  FileAttribute_System            = 0x00000004,
  FileAttribute_Directory         = 0x00000010,
  FileAttribute_Archive           = 0x00000020,
  FileAttribute_Encrypted         = 0x00000040,
  FileAttribute_Normal            = 0x00000080,
  FileAttribute_Temporary         = 0x00000100,
  FileAttribute_SparseFile        = 0x00000200,
  FileAttribute_ReparsePoint      = 0x00000400,
  FileAttribute_Compressed        = 0x00000800,
  FileAttribute_Offline           = 0x00001000,
  FileAttribute_NotContentIndexed = 0x00002000,
} FileAttributes;


/////////////////////////////////////////////////////////////////////////////
// Include the XML/XSL-generated file
#include <AGCEventsIDL.idl>


/////////////////////////////////////////////////////////////////////////////
[
  object, hidden, restricted, pointer_default(unique), nonextensible, oleautomation,
  uuid(4CFC5FEC-243A-11d3-AF03-0000F810C3F4),
  helpstring("Interface implemented by the hosting application to receive triggered events. Intended for use ONLY by host applications.")
]
interface IAGCEventSink : IUnknown
{
  [helpstring("Called when an AGC event has been triggered.")]
  HRESULT OnEventTriggered([in] IAGCEvent* pEvent);

}; // End: interface IAGCEventSink : IUnknown
                       

/////////////////////////////////////////////////////////////////////////////
[
  object, hidden, restricted, pointer_default(unique), nonextensible, oleautomation,
  uuid(4852B61D-0D40-428b-A6C2-9276700F0FCD),
  helpstring("Interface implemented by the hosting application to receive triggered events. Intended for use ONLY by host applications.")
]
interface IAGCEventSinkSynchronous : IUnknown
{
  [helpstring("Called when an AGC event has been triggered.")]
  HRESULT OnEventTriggeredSynchronous([in] IAGCEvent* pEvent);

}; // End: interface IAGCEventSinkSynchronous : IUnknown
                       

/////////////////////////////////////////////////////////////////////////////
// Used by the IAGCGlobal::RegisterObjectCreator method.
//
typedef HRESULT (__stdcall *PFNAGCCreator)(void*, REFIID, void**);


/////////////////////////////////////////////////////////////////////////////
// Used by the IAGCGlobal::EventListeners, TriggerEvent, FreeListeners methods.
//
typedef void* HAGCLISTENERS;


/////////////////////////////////////////////////////////////////////////////
[
  object, local, hidden, restricted, pointer_default(unique), nonextensible,
  uuid(9A153413-CC15-4ea1-A9BB-E0854726CAED),
  helpstring("Implemented by an AGC host to hook debug events.")
]
interface IAGCDebugHook : IUnknown
{
  [helpstring("Called to output the specified text to the debug monitor.")]
  void DebugOutput([in] LPCSTR psz);

  [helpstring("Called when an assertion fails.")]
  boolean OnAssert([in] LPCSTR psz, [in] LPCSTR pszFile,
    [in] int line, [in] LPCSTR pszModule);

  [helpstring("Called to break into a debugger after an assertion fails.")]
  void OnAssertBreak();
};


/////////////////////////////////////////////////////////////////////////////
[
//  object,
  local, hidden, restricted, pointer_default(unique), nonextensible,
  uuid(F4385BC0-1FCC-11d3-AF03-0000F810C3F4),
  helpstring("Interface to the AGC Global object. Intended for use ONLY by host applications that deal directly with Igc.")
]
interface IAGCGlobal : IUnknown
{
  // Object Creation Registration
  [helpstring("Registers the function that is called to create the object that suports the specified interface")]
  void RegisterObjectCreator([in] REFIID riid, [in] PFNAGCCreator pfnCreator);

  [helpstring("Revokes the function that is called to create the object that suports the specified interface")]
  void RevokeObjectCreator([in] REFIID riid);

  // IGC to AGC Mapping
  [helpstring("Finds or makes an AGC object, given a pointer to an IGC object.")]
  HRESULT GetAGCObject([in] const void* pvIgc, [in] REFIID riid,
    [out, iid_is(riid)] void** ppUnk);

  [helpstring("Adds a mapping of an Igc object pointer to an AGC object.")]
  void AddAGCObject([in] const void* pvIgc, [in] IUnknown* pUnkAGC);

  [helpstring("Removes a mapping of the specified AGC object.")]
  void RemoveAGCObject([in] const void* pvIgc, [in] boolean bForceDestruct);

  // Event Registration
  [helpstring("When true, indicates that all IAGCEventSink* parameters are actually GIT cookies.")]
  void SetEventSinksAreGITCookies([in] boolean bEventSinksAreGITCookies);

  [helpstring("When true, indicates that all IAGCEventSink* parameters are actually GIT cookies.")]
  boolean GetEventSinksAreGITCookies();

  [helpstring("Registers an event sink for the specified event.")]
  void RegisterEvent([in] AGCEventID eventID, [in] AGCUniqueID uniqueID,
    [in] IAGCEventSink* pEventSink);

  [helpstring("Revokes an event sink for the specified event.")]
  boolean RevokeEvent([in] AGCEventID eventID, [in] AGCUniqueID uniqueID,
    [in] IAGCEventSink* pEventSink);

  [helpstring("Registers an event sink for the specified ranges of events.")]
  void RegisterEventRanges([in] IAGCEventIDRanges* pRanges,
    [in] AGCUniqueID uniqueID, [in] IAGCEventSink* pEventSink);

  [helpstring("Revokes an event sink for the specified ranges of events.")]
  void RevokeEventRanges([in] IAGCEventIDRanges* pRanges,
    [in] AGCUniqueID uniqueID, [in] IAGCEventSink* pEventSink);

  [helpstring("Revokes an event sink for all its registered events.")]
  int RevokeAllEvents([in] IAGCEventSink* pEventSink);

  [helpstring("Registers an event sink for all available events.")]
  int RegisterAllEvents([in] IAGCEventSink* pEventSink);

  [helpstring("Returns a non-zero handle if someone wants to know about an event. This handle should be released by passing it to either TriggerEvent or FreeListeners.")]
  HAGCLISTENERS EventListeners([in] AGCEventID idEvent, [in] AGCUniqueID idSubject,
    [in] AGCUniqueID idObject1, [in] AGCUniqueID idObject2);

  [helpstring("Notifies registered event sinks that the specified event occurred. Internally calls FreeListeners before returning.")]
  void TriggerEvent([in] HAGCLISTENERS hListeners, [in] AGCEventID idEvent,
    [in] LPCSTR pszContext, [in] LPCOLESTR pszSubject, [in] AGCUniqueID idSubject,
    [in] AGCUniqueID idObject1, [in] AGCUniqueID idObject2,
    [in] long cArgTriplets, [in] void* pvArgs);

  [helpstring("Notifies registered event sinks that the specified event occurred. Internally calls FreeListeners before returning. Does not return until the listener thread processes the event.")]
  void TriggerEventSynchronous([in] HAGCLISTENERS hListeners, [in] AGCEventID idEvent,
    [in] LPCSTR pszContext, [in] LPCOLESTR pszSubject, [in] AGCUniqueID idSubject,
    [in] AGCUniqueID idObject1, [in] AGCUniqueID idObject2,
    [in] long cArgTriplets, [in] void* pvArgs);

  [helpstring("Frees the list of event sinks allocated by EventListeners. Only use if you don't pass the handle to TriggerEvent.")]
  void FreeListeners([in] HAGCLISTENERS hListeners);

  [helpstring("Determines if the specified event sink is registered for the specified event.")]
  boolean IsRegistered([in] AGCEventID eventID, [in] AGCUniqueID uniqueID,
    [in] IAGCEventSink* pEventSink);

  [helpstring("Create an AGCEvent object, initialized with the specified arguments.")]
  HRESULT MakeAGCEvent([in] AGCEventID idEvent, [in] LPCSTR pszContext,
    [in] LPCOLESTR pszSubject, [in] AGCUniqueID idSubject,
    [in] long cArgTriplets, [in] void* pvArgs,
    [out, retval] IAGCEvent** ppEvent);

  [helpstring("Sets the ranges of event ID's available from the host application.")]
  void SetAvailableEventIDRanges([in] IAGCEventIDRanges* pRanges);

  [helpstring("Gets the ranges of event ID's available from the host application.")]
  void GetAvailableEventIDRanges([out, retval] IAGCEventIDRanges** ppRanges);

  [helpstring("Gets the severity of the specified event.")]
  WORD GetEventSeverity([in] AGCEventID idEvent);

  // Miscellaneous
  [helpstring("Gets the resource instance handle of the AGC.DLL module.")]
  HINSTANCE GetResourceInstance();

  [helpstring("Creates an AGCVector object, initialized with the specified raw ZLib vector.")]
  HRESULT MakeAGCVector([in] const void* pVectorRaw,
    [out, retval] IAGCVector** ppVector);

  [helpstring("Creates an AGCOrientation object, initialized with the specified raw ZLib orientation.")]
  HRESULT MakeAGCOrientation([in] const void* pOrientationRaw,
    [out, retval] IAGCOrientation** ppOrientation);

  [helpstring("Creates an AGCEventIDRange object, initialized with the specified values.")]
  HRESULT MakeAGCEventIDRange([in] AGCEventID lower, [in] AGCEventID upper,
    [out, retval] IAGCEventIDRange** ppRange);

  // IGlobalInterfaceTable Interface Methods (delegate to single GIT instance)
  HRESULT RegisterInterfaceInGlobal([in] IUnknown *pUnk, [in] REFIID riid, [out] DWORD* pdwCookie);
  HRESULT RevokeInterfaceFromGlobal([in] DWORD dwCookie);
  HRESULT GetInterfaceFromGlobal([in] DWORD dwCookie,[in] REFIID riid, [out, iid_is(riid)] void** ppv);

  // Object Initialization and Cleanup
  void Initialize();
  void Terminate();

  // Debug Support
  [helpstring("Sets the callback interface used to hook debug events.")]
  void SetDebugHook([in] IAGCDebugHook* pdh);

}; // End: interface IAGCGlobal : IUnknown


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(EFC30B36-13B1-11d3-8B5E-00C04F681633),
  helpstring("Interface to a AGC Vector object.")
]
interface IAGCVector : IDispatch
{
  [propput, helpstring("Gets/sets the x coordinate of the vector.")]
  HRESULT X([in] float xArg);
  [propget, id(dispid_VectorX)]
  HRESULT X([out, retval] float* pxArg);

  [propput, helpstring("Gets/sets the y coordinate of the vector.")]
  HRESULT Y([in] float yArg);
  [propget, id(dispid_VectorY)]
  HRESULT Y([out, retval] float* pyArg);

  [propput, helpstring("Gets/sets the z coordinate of the vector.")]
  HRESULT Z([in] float zArg);
  [propget, id(dispid_VectorZ)]
  HRESULT Z([out, retval] float* pzArg);

  [propput, helpstring("Gets/sets the displayable string representation of the vector.")]
  HRESULT DisplayString([in] BSTR bstrDisplayString);
  [propget, id(DISPID_VALUE), helpstring("Gets the displayable string representation of the vector.")]
  HRESULT DisplayString([out, retval] BSTR* pbstrDisplayString);

  [helpstring("Initializes the object with the specified x, y, and z values.")]
  HRESULT InitXYZ([in] float xArg, [in] float yArg, [in] float zArg);

  [helpstring("Initializes the object by copying the specified vector's x, y, and z values.")]
  HRESULT InitCopy([in] IAGCVector* pVector);

  [helpstring("Initializes the object with a random direction.")]
  HRESULT InitRandomDirection();

  [helpstring("Initializes the object with a random position.")]
  HRESULT InitRandomPosition([in] float fRadius);

  [propget, helpstring("Compares the object to a zero vector.")]
  HRESULT IsZero([out, retval] VARIANT_BOOL* pbIsZero);

  [propget, helpstring("Compares the object to the specified vector.")]
  HRESULT IsEqual([in] IAGCVector* pVector, [out, retval] VARIANT_BOOL* pbIsEqual);

  [propget, helpstring("Computes the length of the object from a zero vector.")]
  HRESULT Length([out, retval] float* pfLength);

  [propget, helpstring("Computes the squared length of the object from a zero vector.")]
  HRESULT LengthSquared([out, retval] float* pfLengthSquared);

  [propget, helpstring("Computes the orthogonal vector of the object.")]
  HRESULT OrthogonalVector([out, retval] IAGCVector** ppResult);

  [helpstring("Computes the sum of the object and the specified vector. Does not modify the object.")]
  HRESULT Add([in] IAGCVector* pVector, [out, retval] IAGCVector** ppResult);

  [helpstring("Computes the difference of the object and the specified vector. Does not modify the object.")]
  HRESULT Subtract([in] IAGCVector* pVector, [out, retval] IAGCVector** ppResult);

  [helpstring("Computes the product of the object and the specified multiplier value. Does not modify the object.")]
  HRESULT Multiply([in] float f, [out, retval] IAGCVector** ppResult);

  [helpstring("Computes the quotient of the object and the specified divisor value. Does not modify the object.")]
  HRESULT Divide([in] float f, [out, retval] IAGCVector** ppResult);

  [helpstring("Computes the normalized vector of the object. Does not modify the object.")]
  HRESULT Normalize([out, retval] IAGCVector** ppResult);

  [helpstring("Computes the cross product of the object and the specified vector. Does not modify the object.")]
  HRESULT CrossProduct([in] IAGCVector* pVector, [out, retval] IAGCVector** ppResult);

  [helpstring("Computes an interpolation of the object with the specified vector. Does not modify the object.")]
  HRESULT Interpolate([in] IAGCVector* pVector, [in] float fValue, [out, retval] IAGCVector** ppResult);

  [helpstring("Computes the sum of the object and the specified vector, with the result being stored in the object.")]
  HRESULT AddInPlace([in] IAGCVector* pVector);

  [helpstring("Computes the difference of the object and the specified vector, with the result being stored in the object.")]
  HRESULT SubtractInPlace([in] IAGCVector* pVector);

  [helpstring("Computes the product of the object and the specified multiplier value, with the result being stored in the object.")]
  HRESULT MultiplyInPlace([in] float f);

  [helpstring("Computes the quotient of the object and the specified divisor value, with the result being stored in the object.")]
  HRESULT DivideInPlace([in] float f);

  [helpstring("Computes the normalized vector of the object, with the result being stored in the object.")]
  HRESULT NormalizeInPlace();

  [helpstring("Computes the cross product of the object and the specified vector, with the result being stored in the object.")]
  HRESULT CrossProductInPlace([in] IAGCVector* pVector);

  [helpstring("Computes an interpolation of the object with the specified vector, with the result being stored in the object.")]
  HRESULT InterpolateInPlace([in] IAGCVector* pVector, [in] float fValue);

}; // End: interface IAGCVector : IDispatch


/////////////////////////////////////////////////////////////////////////////
// IAGCVectorPrivate
[
  hidden, restricted, object, local, pointer_default(unique), nonextensible,
  uuid(9DAF96AE-2F5A-11d3-A51C-00C04F68DEB0),
  helpstring("Private interface to an AGC Vector object.")
]
interface IAGCVectorPrivate : IUnknown
{
  [helpstring("Initializes the object from a raw (ZLib/IGC) Vector pointer.")]
  HRESULT InitFromVector([in] const void* pvVector);

  [helpstring("Copies the object's raw (ZLib/IGC) Vector to the specified Vector pointer.")]
  HRESULT CopyVectorTo([in, out] void* pvVector);

}; // End: interface IAGCVectorPrivate : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(C6D92776-3998-11d3-A51D-00C04F68DEB0),
  helpstring("Interface to an AGC Orientation object.")
]
interface IAGCOrientation : IDispatch
{
  [helpstring("Initializes the object by copying the specified object.")]
  HRESULT InitCopy(IAGCOrientation* pOrientation);

  [propget, helpstring("Gets the Forward vector of the orientation matrix.")]
  HRESULT Forward([out, retval] IAGCVector** ppVector);

  [propget, helpstring("Gets the Backward vector of the orientation matrix.")]
  HRESULT Backward([out, retval] IAGCVector** ppVector);

  [propget, helpstring("Gets the Up vector of the orientation matrix.")]
  HRESULT Up([out, retval] IAGCVector** ppVector);

  [propget, helpstring("Gets the Right vector of the orientation matrix.")]
  HRESULT Right([out, retval] IAGCVector** ppVector);

  [propget, helpstring("Compares the object to the specified object for absolute equality.")]
  HRESULT IsEqual([in] IAGCOrientation* pOrientation,
    [out, retval] VARIANT_BOOL* pbIsEqual);

  [propget, helpstring("Compares the object to the specified object for 'fuzzy' equality.")]
  HRESULT IsRoughlyEqual([in] IAGCOrientation* pOrientation,
    [out, retval] VARIANT_BOOL* pbIsEqual);

}; // End: interface IAGCOrientation : IDispatch


/////////////////////////////////////////////////////////////////////////////
// IAGCOrientationPrivate
[
  hidden, restricted, object, local, pointer_default(unique), nonextensible,
  uuid(C6D92777-3998-11d3-A51D-00C04F68DEB0),
  helpstring("Private interface to an AGC Orientation object.")
]
interface IAGCOrientationPrivate : IUnknown
{
  [helpstring("Initializes the object from a raw (ZLib/IGC) Orientation pointer.")]
  HRESULT InitFromOrientation([in] const void* pvOrientation);

  [helpstring("Copies the object's raw (ZLib/IGC) Orientation to the specified Orientation pointer.")]
  HRESULT CopyOrientationTo([in, out] void* pvOrientation);

}; // End: interface IAGCOrientationPrivate : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(07000E96-F4F6-4b49-9680-77B770B83905),
  helpstring("IAGCEventType Interface")
]
interface IAGCEventType : IDispatch
{
}; // End: interface IAGCEventType : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(D2EFE888-1480-11d3-8B5F-00C04F681633),
  helpstring("IAGCEvent Interface")
]
interface IAGCEvent : IDispatch
{
  [propget, helpstring("Gets the event identifier.")]
  HRESULT ID([out, retval] AGCEventID* pVal);

  [propget, helpstring("Gets the date and time that the event occurred.")]
  HRESULT Time([out, retval] DATE* pVal);
    
  [propget, helpstring("Gets the textual description of the event that occurred.")]
  HRESULT Description([out, retval] BSTR* bstr);
    
  [propget, helpstring("Gets the number of event parameters in the property map.")]
  HRESULT PropertyCount([out, retval] long* pnCount);

  [propget, helpstring("Gets whether or not the specified event parameter is in the property map.")]
  HRESULT PropertyExists([in] BSTR bstrKey, [out, retval] VARIANT_BOOL* pbExists);

  [propget, id(DISPID_VALUE), helpstring("Gets the specified event parameter from the property map.")]
  HRESULT Property([in, defaultvalue(NULL)] VARIANT* pvKey,
    [out, retval] VARIANT* pvValue);

  [propget, helpstring("Gets the name of the computer on which the event occurred.")]
  HRESULT ComputerName([out, retval] BSTR* pbstrComputerName);

  [propget, helpstring("Gets the ID of the subject of the event, if any. Otherwise, -1.")]
  HRESULT SubjectID([out, retval] long* pidSubject);

  [propget, helpstring("Gets the name of the subject of the event, if any.")]
  HRESULT SubjectName([out, retval] BSTR* pbstrSubject);

  [helpstring("Persists the object to a string representation, to be resolved with LoadFromString.")]
  HRESULT SaveToString([out, retval] BSTR* pbstr);

  [helpstring("Initializes the object from a persistence string returned by SaveToString.")]
  HRESULT LoadFromString([in] BSTR bstr);

  [propget, helpstring("Gets a string representing the context in which the event occurred.")]
  HRESULT Context([out, retval] BSTR* pbstrContext);

}; // End: interface IAGCEvent : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(9D43ACA9-98A3-45ba-BFAA-340D451FCD98),
  helpstring("IAGCEventCreate Interface")
]
interface IAGCEventCreate : IDispatch
{
  [helpstring("Initializes object.")]
  HRESULT Init();

  [propput, helpstring("Sets the event identifier.")]
  HRESULT ID([in] AGCEventID Val);

  [propput, helpstring("Sets the date and time that the event occurred.")]
  HRESULT Time([in] DATE Val);

  [helpstring("Sets the time property to the current date/time.")]    
  HRESULT SetTimeNow();

  [helpstring("Adds the specified event parameter to the property map.")]
  HRESULT AddProperty([in] BSTR pbstrKey, [in] VARIANT* pvValue);

  [helpstring("Removes the specified event parameter from the property map.")]
  HRESULT RemoveProperty([in] BSTR pbstrKey, [in] VARIANT* pvValue);

  [propput, helpstring("Sets the ID of the subject of the event, if any. Otherwise, -1.")]
  HRESULT SubjectID([in] long idSubject);

  [propput, helpstring("Sets the name of the subject of the event, if any.")]
  HRESULT SubjectName([in] BSTR bstrSubject);

  [propput, helpstring("Sets the string representing the context in which the event occurred.")]
  HRESULT Context([in] BSTR bstrContext);

}; // End: interface IAGCEventCreate : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(E71EA5B9-EBA4-11D2-8B4B-00C04F681633),
  helpstring("IAGCGameParameters Interface")
]
interface IAGCGameParameters : IDispatch
{
  [helpstring("Validates the properties of the object.")]
  HRESULT Validate();

  [propput, helpstring("Gets/sets the minimum players per team.")]
  HRESULT MinPlayers([in] BYTE Val);
  [propget]
  HRESULT MinPlayers([out, retval] BYTE* pVal);

  [propput, helpstring("Gets/sets the maximum players per team.")]
  HRESULT MaxPlayers([in] BYTE Val);
  [propget]
  HRESULT MaxPlayers([out, retval] BYTE* pVal);

  [propget, id(DISPID_VALUE), helpstring("property GameName")] HRESULT GameName([out, retval] BSTR *pVal);
  [propput, id(DISPID_VALUE), helpstring("property GameName")] HRESULT GameName([in] BSTR newVal);
  [propget, helpstring("property EjectPods")] HRESULT EjectPods([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property EjectPods")] HRESULT EjectPods([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowPrivateTeams")] HRESULT AllowPrivateTeams([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowPrivateTeams")] HRESULT AllowPrivateTeams([in] VARIANT_BOOL newVal);
  [propget, helpstring("property PowerUps")] HRESULT PowerUps([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property PowerUps")] HRESULT PowerUps([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowJoiners")] HRESULT AllowJoiners([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowJoiners")] HRESULT AllowJoiners([in] VARIANT_BOOL newVal);
  [propget, helpstring("property Stations")] HRESULT Stations([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property Stations")] HRESULT Stations([in] VARIANT_BOOL newVal);
  [propget, helpstring("property ScoresCount")] HRESULT ScoresCount([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property ScoresCount")] HRESULT ScoresCount([in] VARIANT_BOOL newVal);
  [propget, helpstring("property Drones")] HRESULT Drones([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property Drones")] HRESULT Drones([in] VARIANT_BOOL newVal);
  [propget, helpstring("property IsGoalConquest")] HRESULT IsGoalConquest([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property IsGoalConquest")] HRESULT IsGoalConquest([in] VARIANT_BOOL newVal);
  [propget, helpstring("property IsGoalArtifacts")] HRESULT IsGoalArtifacts([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property IsGoalArtifacts")] HRESULT IsGoalArtifacts([in] VARIANT_BOOL newVal);
  [propget, helpstring("property IsGoalTeamMoney")] HRESULT IsGoalTeamMoney([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property IsGoalTeamMoney")] HRESULT IsGoalTeamMoney([in] VARIANT_BOOL newVal);
  [propget, helpstring("property IsGoalTeamKills")] HRESULT IsGoalTeamKills([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property IsGoalTeamKills")] HRESULT IsGoalTeamKills([in] VARIANT_BOOL newVal);
  [propget, helpstring("property Resources")] HRESULT Resources([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property Resources")] HRESULT Resources([in] VARIANT_BOOL newVal);
  [propget, helpstring("property ResourceAmountsVisible")] HRESULT ResourceAmountsVisible([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property ResourceAmountsVisible")] HRESULT ResourceAmountsVisible([in] VARIANT_BOOL newVal);
  [propget, helpstring("property RandomWormholes")] HRESULT RandomWormholes([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property RandomWormholes")] HRESULT RandomWormholes([in] VARIANT_BOOL newVal);
  [propget, helpstring("property NoTeams")] HRESULT NoTeams([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property NoTeams")] HRESULT NoTeams([in] VARIANT_BOOL newVal);
  [propget, helpstring("property ShowHomeSector")] HRESULT ShowHomeSector([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property ShowHomeSector")] HRESULT ShowHomeSector([in] VARIANT_BOOL newVal);
  [propget, helpstring("property CivIDs")] HRESULT CivIDs(short element, [out, retval] short *pVal);
  [propput, helpstring("property CivIDs")] HRESULT CivIDs(short element, [in] short newVal);
  [propget, helpstring("property GoalTeamMoney")] HRESULT GoalTeamMoney([out, retval] AGCMoney *pVal);
  [propput, helpstring("property GoalTeamMoney")] HRESULT GoalTeamMoney([in] AGCMoney newVal);
  [propget, helpstring("property TsiPlayerStart")] HRESULT TsiPlayerStart([out, retval] short *pVal);
  [propput, helpstring("property TsiPlayerStart")] HRESULT TsiPlayerStart([in] short newVal);
  [propget, helpstring("property TsiNeutralStart")] HRESULT TsiNeutralStart([out, retval] short *pVal);
  [propput, helpstring("property TsiNeutralStart")] HRESULT TsiNeutralStart([in] short newVal);
  [propget, helpstring("property TsiPlayerRegenerate")] HRESULT TsiPlayerRegenerate([out, retval] short *pVal);
  [propput, helpstring("property TsiPlayerRegenerate")] HRESULT TsiPlayerRegenerate([in] short newVal);
  [propget, helpstring("property TsiNeutralRegenerate")] HRESULT TsiNeutralRegenerate([out, retval] short *pVal);
  [propput, helpstring("property TsiNeutralRegenerate")] HRESULT TsiNeutralRegenerate([in] short newVal);
  [propget, helpstring("property StartingMoney")] HRESULT StartingMoney([out, retval] float *pVal);
  [propput, helpstring("property StartingMoney")] HRESULT StartingMoney([in] float newVal);
  [propget, helpstring("property Lives")] HRESULT Lives([out, retval] short *pVal);
  [propput, helpstring("property Lives")] HRESULT Lives([in] short newVal);
  [propget, helpstring("property GoalTeamKills")] HRESULT GoalTeamKills([out, retval] short *pVal);
  [propput, helpstring("property GoalTeamKills")] HRESULT GoalTeamKills([in] short newVal);
  [propget, helpstring("property MapType")] HRESULT MapType([out, retval] short *pVal);
  [propput, helpstring("property MapType")] HRESULT MapType([in] short newVal);
  [propget, helpstring("property MapSize")] HRESULT MapSize([out, retval] short *pVal);
  [propput, helpstring("property MapSize")] HRESULT MapSize([in] short newVal);
  [propget, helpstring("property RandomEncounters")] HRESULT RandomEncounters([out, retval] short *pVal);
  [propput, helpstring("property RandomEncounters")] HRESULT RandomEncounters([in] short newVal);
  [propget, helpstring("property NeutralSectors")] HRESULT NeutralSectors([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property NeutralSectors")] HRESULT NeutralSectors([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AlephPositioning")] HRESULT AlephPositioning([out, retval] short *pVal);
  [propput, helpstring("property AlephPositioning")] HRESULT AlephPositioning([in] short newVal);
  [propget, helpstring("property AlephsPerSector")] HRESULT AlephsPerSector([out, retval] short *pVal);
  [propput, helpstring("property AlephsPerSector")] HRESULT AlephsPerSector([in] short newVal);
  [propget, helpstring("property Teams")] HRESULT Teams([out, retval] short *pVal);
  [propput, helpstring("property Teams")] HRESULT Teams([in] short newVal);
  [propget, helpstring("property MinRank")] HRESULT MinRank([out, retval] short *pVal);
  [propput, helpstring("property MinRank")] HRESULT MinRank([in] short newVal);
  [propget, helpstring("property MaxRank")] HRESULT MaxRank([out, retval] short *pVal);
  [propput, helpstring("property MaxRank")] HRESULT MaxRank([in] short newVal);
  [propget, helpstring("property PlayerSectorAsteroids")] HRESULT PlayerSectorAsteroids([out, retval] short *pVal);
  [propput, helpstring("property PlayerSectorAsteroids")] HRESULT PlayerSectorAsteroids([in] short newVal);
  [propget, helpstring("property NeutralSectorAsteroids")] HRESULT NeutralSectorAsteroids([out, retval] short *pVal);
  [propput, helpstring("property NeutralSectorAsteroids")] HRESULT NeutralSectorAsteroids([in] short newVal);
  [propget, helpstring("property PlayerSectorTreasures")] HRESULT PlayerSectorTreasures([out, retval] short *pVal);
  [propput, helpstring("property PlayerSectorTreasures")] HRESULT PlayerSectorTreasures([in] short newVal);
  [propget, helpstring("property NeutralSectorTreasures")] HRESULT NeutralSectorTreasures([out, retval] short *pVal);
  [propput, helpstring("property NeutralSectorTreasures")] HRESULT NeutralSectorTreasures([in] short newVal);
  [propget, helpstring("property PlayerSectorTreasureRate")] HRESULT PlayerSectorTreasureRate([out, retval] FLOAT *pVal);
  [propput, helpstring("property PlayerSectorTreasureRate")] HRESULT PlayerSectorTreasureRate([in] FLOAT newVal);
  [propget, helpstring("property NeutralSectorTreasureRate")] HRESULT NeutralSectorTreasureRate([out, retval] FLOAT *pVal);
  [propput, helpstring("property NeutralSectorTreasureRate")] HRESULT NeutralSectorTreasureRate([in] FLOAT newVal);
  [propget, helpstring("property PlayerSectorMineableAsteroids")] HRESULT PlayerSectorMineableAsteroids([out, retval] short *pVal);
  [propput, helpstring("property PlayerSectorMineableAsteroids")] HRESULT PlayerSectorMineableAsteroids([in] short newVal);
  [propget, helpstring("property NeutralSectorMineableAsteroids")] HRESULT NeutralSectorMineableAsteroids([out, retval] short *pVal);
  [propput, helpstring("property NeutralSectorMineableAsteroids")] HRESULT NeutralSectorMineableAsteroids([in] short newVal);
  [propget, helpstring("property PlayerSectorSpecialAsteroids")] HRESULT PlayerSectorSpecialAsteroids([out, retval] short *pVal);
  [propput, helpstring("property PlayerSectorSpecialAsteroids")] HRESULT PlayerSectorSpecialAsteroids([in] short newVal);
  [propget, helpstring("property NeutralSectorSpecialAsteroids")] HRESULT NeutralSectorSpecialAsteroids([out, retval] short *pVal);
  [propput, helpstring("property NeutralSectorSpecialAsteroids")] HRESULT NeutralSectorSpecialAsteroids([in] short newVal);
  [propget, helpstring("property IGCStaticFile")] HRESULT IGCStaticFile([out, retval] BSTR *pVal);
  [propput, helpstring("property IGCStaticFile")] HRESULT IGCStaticFile([in] BSTR newVal);
  [propget, helpstring("property GamePassword")] HRESULT GamePassword([out, retval] BSTR *pVal);
  [propput, helpstring("property GamePassword")] HRESULT GamePassword([in] BSTR newVal);
  [propget, helpstring("property InvulnerableStations")] HRESULT InvulnerableStations([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property InvulnerableStations")] HRESULT InvulnerableStations([in] VARIANT_BOOL newVal);
  [propget, helpstring("property ShowMap")] HRESULT ShowMap([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property ShowMap")] HRESULT ShowMap([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowDevelopments")] HRESULT AllowDevelopments([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowDevelopments")] HRESULT AllowDevelopments([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowDefections")] HRESULT AllowDefections([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowDefections")] HRESULT AllowDefections([in] VARIANT_BOOL newVal);
  [propget, helpstring("property SquadGame")] HRESULT SquadGame([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property SquadGame")] HRESULT SquadGame([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowFriendlyFire")] HRESULT AllowFriendlyFire([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowFriendlyFire")] HRESULT AllowFriendlyFire([in] VARIANT_BOOL newVal);
  [propget, helpstring("property IGCcoreVersion")] HRESULT IGCcoreVersion([out, retval] long *pVal);
  [propget, helpstring("property GameLength")] HRESULT GameLength([out, retval] float *pVal);
  [propput, helpstring("property GameLength")] HRESULT GameLength([in] float newVal);
  [propget, helpstring("property He3Density")] HRESULT He3Density([out, retval] float *pVal);
  [propput, helpstring("property He3Density")] HRESULT He3Density([in] float newVal);
  [propget, helpstring("property KillPenalty")] HRESULT KillPenalty([out, retval] AGCMoney *pVal);
  [propput, helpstring("property KillPenalty")] HRESULT KillPenalty([in] AGCMoney newVal);
  [propget, helpstring("property KillReward")] HRESULT KillReward([out, retval] AGCMoney *pVal);
  [propput, helpstring("property KillReward")] HRESULT KillReward([in] AGCMoney newVal);
  [propget, helpstring("property EjectPenalty")] HRESULT EjectPenalty([out, retval] AGCMoney *pVal);
  [propput, helpstring("property EjectPenalty")] HRESULT EjectPenalty([in] AGCMoney newVal);
  [propget, helpstring("property EjectReward")] HRESULT EjectReward([out, retval] AGCMoney *pVal);
  [propput, helpstring("property EjectReward")] HRESULT EjectReward([in] AGCMoney newVal);
  [propget, helpstring("property TimeStart")] HRESULT TimeStart([out, retval] double *pVal);
  [propget, helpstring("property TimeStartClock")] HRESULT TimeStartClock([out, retval] long *pVal);
  [propget, helpstring("property GoalArtifactsCount")] HRESULT GoalArtifactsCount([out, retval] short *pVal);
  [propput, helpstring("property GoalArtifactsCount")] HRESULT GoalArtifactsCount([in] short newVal);
  [propget, helpstring("property AutoRestart")] HRESULT AutoRestart([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AutoRestart")] HRESULT AutoRestart([in] VARIANT_BOOL newVal);
  [propget, helpstring("property DefaultCountdown (in seconds)")] HRESULT DefaultCountdown([out, retval] float *pVal);
  [propput, helpstring("property DefaultCountdown (in seconds)")] HRESULT DefaultCountdown([in] float newVal);
  [propget, helpstring("property InitialMinersPerTeam")] HRESULT InitialMinersPerTeam([out, retval] BYTE *pVal);
  [propput, helpstring("property InitialMinersPerTeam")] HRESULT InitialMinersPerTeam([in] BYTE newVal);
  [propget, helpstring("property MaxMinersPerTeam")] HRESULT MaxMinersPerTeam([out, retval] BYTE *pVal);
  [propput, helpstring("property MaxMinersPerTeam")] HRESULT MaxMinersPerTeam([in] BYTE newVal);
  [propget, helpstring("property CustomMap")] HRESULT CustomMap([out, retval] BSTR *pVal);
  [propput, helpstring("property CustomMap")] HRESULT CustomMap([in] BSTR newVal);
  [propget, helpstring("property RestartCountdown (in seconds)")] HRESULT RestartCountdown([out, retval] float *pVal);
  [propput, helpstring("property RestartCountdown (in seconds)")] HRESULT RestartCountdown([in] float newVal);
  [propget, helpstring("property TotalMaxPlayers (for the entire game)")] HRESULT TotalMaxPlayers([out, retval] short* pVal);
  [propput, helpstring("property TotalMaxPlayers (for the entire game)")] HRESULT TotalMaxPlayers([in] short newVal);
  [propget, helpstring("property LockTeamSettings (locks settings for players not admins)")] HRESULT LockTeamSettings([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property LockTeamSettings (locks settings for players not admins)")] HRESULT LockTeamSettings([in] VARIANT_BOOL newVal);
  [propget, helpstring("property InvitationListID")] HRESULT InvitationListID([out, retval] int *pVal);
  [propput, helpstring("property InvitationListID")] HRESULT InvitationListID([in] int newVal);
  [propget, helpstring("property IsSquadGame")] HRESULT IsSquadGame([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property IsSquadGame")] HRESULT IsSquadGame([in] VARIANT_BOOL newVal);
  [propget, helpstring("property LockGameOpen")] HRESULT LockGameOpen([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property LockGameOpen")] HRESULT LockGameOpen([in] VARIANT_BOOL newVal);
  [propget, helpstring("property TeamName")] HRESULT TeamName([in] short iTeam, [out, retval] BSTR *pVal);
  [propput, helpstring("property TeamName")] HRESULT TeamName([in] short iTeam, [in] BSTR newVal);
  [propget, helpstring("property IsTechBitOverridden; returns true iff OverriddenTechBit was set for this Team's BitID")] HRESULT IsTechBitOverridden([in] short iTeam, [in] short iBitID, [out, retval] VARIANT_BOOL *pVal);
  [propget, helpstring("property OverriddenTechBit")] HRESULT OverriddenTechBit([in] short iTeam, [in] short iBitID, [out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property OverriddenTechBit")] HRESULT OverriddenTechBit([in] short iTeam, [in] short iBitID, [in] VARIANT_BOOL newVal);
  [propput, helpstring("property SetOverriddenTechBitRange")] HRESULT SetOverriddenTechBitRange([in] short iTeam, [in] short iBitID_First, [in] short iBitID_Last, [in] VARIANT_BOOL newVal);
  [propget, helpstring("property IsGoalFlags")] HRESULT IsGoalFlags([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property IsGoalFlags")] HRESULT IsGoalFlags([in] VARIANT_BOOL newVal);
  [propget, helpstring("property GoalFlagsCount")] HRESULT GoalFlagsCount([out, retval] short *pVal);
  [propput, helpstring("property GoalFlagsCount")] HRESULT GoalFlagsCount([in] short newVal);
  [propget, helpstring("The text that describes the story of the game.")]
  HRESULT StoryText([out, retval] BSTR* pbstrStory);
  [propput]
  HRESULT StoryText([in] BSTR bstrStory);
  [propget, helpstring("property AllowEmptyTeams")] HRESULT AllowEmptyTeams([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowEmptyTeams")] HRESULT AllowEmptyTeams([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AutoStart")] HRESULT AutoStart([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AutoStart")] HRESULT AutoStart([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowRestart")] HRESULT AllowRestart([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowRestart")] HRESULT AllowRestart([in] VARIANT_BOOL newVal);
  [propget, helpstring("property Experimental")] HRESULT Experimental([out, retval] VARIANT_BOOL *pVal); // mmf 10/07 Experimental game type
  [propput, helpstring("property Experimental")] HRESULT Experimental([in] VARIANT_BOOL newVal);         // mmf 10/07 Experimental game type
  [propget, helpstring("property AllowShipyardPath")] HRESULT AllowShipyardPath([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowShipyardPath")] HRESULT AllowShipyardPath([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowSupremacyPath")] HRESULT AllowSupremacyPath([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowSupremacyPath")] HRESULT AllowSupremacyPath([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowTacticalPath")] HRESULT AllowTacticalPath([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowTacticalPath")] HRESULT AllowTacticalPath([in] VARIANT_BOOL newVal);
  [propget, helpstring("property AllowExpansionPath")] HRESULT AllowExpansionPath([out, retval] VARIANT_BOOL *pVal);
  [propput, helpstring("property AllowExpansionPath")] HRESULT AllowExpansionPath([in] VARIANT_BOOL newVal);
  [propget, helpstring("property MaxImbalance: Maximum allowed difference between smallest and largest team.")]
  HRESULT MaxImbalance([out, retval] short* pVal);
  [propput]
  HRESULT MaxImbalance([in] short Val);
};


/////////////////////////////////////////////////////////////////////////////
// IAGCCommand
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(7CDC82F6-FE9D-11d2-A50F-00C04F68DEB0),
  helpstring("Interface to an AGC Command object.")
]
interface IAGCCommand : IDispatch
{
  [propget, id(dispid_Target), helpstring("Gets the command target.")]
  HRESULT Target([out, retval] BSTR* pbstrTarget);

  [propget, id(dispid_Verb), helpstring("Gets the command verb.")]
  HRESULT Verb([out, retval] BSTR* pbstrVerb);

  [propget, id(DISPID_VALUE), helpstring("Gets the textual represenation of the command.")]
  HRESULT Text([out, retval] BSTR* pbstrText);

}; // End: interface IAGCCommand : IDispatch


/////////////////////////////////////////////////////////////////////////////
// IAGCCommandPrivate
[
  hidden, restricted, object, local, pointer_default(unique), nonextensible,
  uuid(FD8B15CA-FF40-11d2-A50F-00C04F68DEB0),
  helpstring("Private interface to an AGC Command object.")
]
interface IAGCCommandPrivate : IUnknown
{
  [helpstring("Initializes the object.")]
  void Init([in] LPCSTR pszTarget, [in] LPCSTR pszVerb);

}; // End: interface IAGCCommandPrivate : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(160DA17D-C8D5-4352-9654-6E658A5A0887),
  helpstring("IAGCVersionInfo Interface")
]
interface IAGCVersionInfo : IDispatch
{
  #include "..\test\TCAtl\VersionInfoImpl.idl"

}; // End: interface IAGCVersionInfo : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(80E3B37A-936E-4dcc-A8AD-DD9658F20613),
  helpstring("IAGCDBParams Interface")
]
interface IAGCDBParams : IDispatch
{
  [propput, helpstring("Gets/sets the database connection string.")]
  HRESULT ConnectionString([in] BSTR bstr);
  [propget]
  HRESULT ConnectionString([out, retval] BSTR* pbstr);

  [propput, helpstring("Gets/sets the table name.")]
  HRESULT TableName([in] BSTR bstr);
  [propget]
  HRESULT TableName([out, retval] BSTR* pbstr);

}; // End: interface IAGCDBParams : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(28755AA1-6391-4d37-A995-5AE387D0B610),
  helpstring("IAGCEventLogger Interface")
]
interface IAGCEventLogger : IDispatch
{
  [propget, helpstring("Gets the entire list of AGC Events as an XML string.")]
  HRESULT EventList([out, retval] BSTR* pbstrEventListXML);

  [propput, helpstring("Gets/sets the name of the (WinNT or Win2000) computer to which AGC Events will be logged as NT Events.")]
  HRESULT NTEventLog([in] BSTR bstrComputer);
  [propget]
  HRESULT NTEventLog([out, retval] BSTR* pbstrComputer);

  [propput, helpstring("Gets/sets the parameters of the database to which AGC Events will be logged.")]
  HRESULT DBEventLog([in] IAGCDBParams* pDBParams);
  [propget]
  HRESULT DBEventLog([out, retval] IAGCDBParams** ppDBParams);

  [propput, helpstring("Gets/sets the range(s) of AGC Events to be logged to the NT Event log.")]
  HRESULT EnabledNTEvents([in] IAGCEventIDRanges* pEvents);
  [propget]
  HRESULT EnabledNTEvents([out, retval] IAGCEventIDRanges** ppEvents);

  [propput, helpstring("Gets/sets the range(s) of AGC Events to be logged to the database event log.")]
  HRESULT EnabledDBEvents([in] IAGCEventIDRanges* pEvents);
  [propget]
  HRESULT EnabledDBEvents([out, retval] IAGCEventIDRanges** ppEvents);

  [propget, helpstring("Gets the default range(s) of AGC Events to be logged to the NT Event log.")]
  HRESULT DefaultEnabledNTEvents([out, retval] IAGCEventIDRanges** ppEvents);

  [propget, helpstring("Gets the default range(s) of AGC Events to be logged to the DB Event log.")]
  HRESULT DefaultEnabledDBEvents([out, retval] IAGCEventIDRanges** ppEvents);

}; // End: interface IAGCEventLogger : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, oleautomation, pointer_default(unique), nonextensible,
  uuid(E3A96B17-84AD-4785-B36B-F5B022473FFB),
  helpstring("Implemented by an AGC host to hook event logging.")
]
interface IAGCEventLoggerHook : IUnknown
{
  [helpstring("Called to allow the host application to log an event in its own way. Host should return S_FALSE to indicate to the event logger that it should perform 'normal' event logging.")]
  HRESULT LogEvent([in] IAGCEvent* pEvent, [in] VARIANT_BOOL bSynchronous);

}; // End: interface IAGCEventLoggerHook : IUnknown


/////////////////////////////////////////////////////////////////////////////
[
  object, oleautomation, pointer_default(unique), nonextensible,
  uuid(264080C0-4D80-4a68-81D4-05B937E8FD3D),
  helpstring("IAGCEventLoggerPrivate Interface")
]
interface IAGCEventLoggerPrivate : IUnknown
{
  [helpstring("Should be called immediately upon creating the object (and from the same thread or apartment).")]
  HRESULT Initialize([in] BSTR bstrSourceApp, [in] BSTR bstrRegKey);

  [helpstring("Should be called immediately prior to releasing the object.")]
  HRESULT Terminate();

  [propput, helpstring("Gets/sets whether or not logging to the NT Event log is enabled or not.")]
  HRESULT LoggingToNTEnabled([in] VARIANT_BOOL bEnabled);
  [propget]
  HRESULT LoggingToNTEnabled([out, retval] VARIANT_BOOL* pbEnabled);

  [propput, helpstring("Gets/sets whether or not logging to the DB Event log is enabled or not.")]
  HRESULT LoggingToDBEnabled([in] VARIANT_BOOL bEnabled);
  [propget]
  HRESULT LoggingToDBEnabled([out, retval] VARIANT_BOOL* pbEnabled);

  [propput, helpstring("Gets/sets a callback interface to hook events logged to the NT Event log.")]
  HRESULT HookForNTLogging([in] IAGCEventLoggerHook* pHook);
  [propget]
  HRESULT HookForNTLogging([out, retval] IAGCEventLoggerHook** ppHook);

  [propput, helpstring("Gets/sets a callback interface to hook events logged to the DB Event log.")]
  HRESULT HookForDBLogging([in] IAGCEventLoggerHook* pHook);
  [propget]
  HRESULT HookForDBLogging([out, retval] IAGCEventLoggerHook** ppHook);

}; // End: interface IAGCEventLoggerPrivate : IUnknown


/////////////////////////////////////////////////////////////////////////////
// IAGCRangePrivate
[
  hidden, restricted, object, local, pointer_default(unique), nonextensible,
  uuid(AD411305-E114-4632-879C-EAE2E8810179),
  helpstring("Private interface to an AGC Range object.")
]
interface IAGCRangePrivate : IUnknown
{
  [helpstring("Initializes the object from a raw (TCLib) range<T> pointer.")]
  HRESULT InitFromRange([in] const void* pvRange);

  [helpstring("Copies the object's raw (TCLib) range to the specified range<T> pointer.")]
  HRESULT CopyRangeTo([in, out] void* pvRange);

}; // End: interface IAGCRangePrivate : IDispatch


/////////////////////////////////////////////////////////////////////////////
// IAGCRangesPrivate
[
  hidden, restricted, object, local, pointer_default(unique), nonextensible,
  uuid(BC666227-D3D2-4387-9341-05D1C9ED3D59),
  helpstring("Private interface to an AGC Ranges object.")
]
interface IAGCRangesPrivate : IUnknown
{
  [helpstring("Initializes the object from a raw (TCLib) rangeset< range<T> > pointer.")]
  HRESULT InitFromRanges([in] const void* pvRanges);

  [helpstring("Copies the object's raw (TCLib) range to the specified rangeset< range<T> > pointer.")]
  HRESULT CopyRangesTo([in, out] void* pvRanges);

}; // End: interface IAGCRangesPrivate : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(0AA7A82F-FCA5-4671-869F-0033A7573D30),
  helpstring("IAGCEventIDRange Interface")
]
interface IAGCEventIDRange : IDispatch
{
  [propput, helpstring("Gets/sets the range as a string, formatted for display purposes.")]
  HRESULT DisplayString([in] BSTR bstr);
  [propget, id(DISPID_VALUE)]
  HRESULT DisplayString([out, retval] BSTR* pbstr);

  [helpstring("Sets the lower and upper (open) ends of the range.")]
  HRESULT Init([in] AGCEventID lower, [in] AGCEventID upper);

  [propget, helpstring("Gets the lower end of the range.")]
  HRESULT Lower([out, retval] AGCEventID* pValue);

  [propget, helpstring("Gets the upper (open) end of the range.")]
  HRESULT Upper([out, retval] AGCEventID* pValue);

  [propget, helpstring("Determines whether this range is empty (Lower equals Upper).")]
  HRESULT IsEmpty([out, retval] VARIANT_BOOL* pbIsEmpty);

  [propget, helpstring("Determines whether the specified value intersects with this range.")]
  HRESULT IntersectsWithValue([in] AGCEventID value,
    [out, retval] VARIANT_BOOL* pbIntersects);

  [propget, helpstring("Determines whether the specified range intersects with this range.")]
  HRESULT IntersectsWithRangeValues([in] AGCEventID value1,
    [in] AGCEventID value2,
    [out, retval] VARIANT_BOOL* pbIntersects);

  [propget, helpstring("Determines whether the specified range intersects with this range.")]
  HRESULT IntersectsWithRange([in] IAGCEventIDRange* pRange,
    [out, retval] VARIANT_BOOL* pbIntersects);

}; // End: interface IAGCEventIDRange : IDispatch


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(481B5D73-C1C4-4936-93C6-C4754F10D497),
  helpstring("IAGCEventIDRanges Interface")
]
interface IAGCEventIDRanges : IDispatch
{
  [propget, helpstring("Returns the number of items in the collection.")]
  HRESULT Count([out, retval] long* pnCount);

  [propget, hidden, restricted, id(DISPID_NEWENUM), helpstring("Returns an enumerator object that implements IEnumVARIANT.")]
  HRESULT _NewEnum([out, retval] IUnknown** ppunkEnum);

  [propget, id(DISPID_VALUE), helpstring("Returns a AGCShip from the collection, or NULL if the item does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCEventIDRange** ppRange);

  [propput, helpstring("Gets/sets the range set as a string, formatted for display purposes.")]
  HRESULT DisplayString([in] BSTR bstr);
  [propget]
  HRESULT DisplayString([out, retval] BSTR* pbstr);

  [helpstring("Adds a range into the set, specified by the range's lower and upper bounds.")]
  HRESULT AddByValues([in] AGCEventID value1, [in] AGCEventID value2);

  [helpstring("Adds a range into the set, specified by a range object.")]
  HRESULT Add([in] IAGCEventIDRange* pRange);

  [helpstring("Removes a range from the set, specified by the range's lower and upper bounds.")]
  HRESULT RemoveByValues([in] AGCEventID value1, [in] AGCEventID value2);

  [helpstring("Removes a range from the set, specified by a range object.")]
  HRESULT Remove([in] IAGCEventIDRange* pRange);

  [helpstring("Removes all ranges from the set, specified by a range object.")]
  HRESULT RemoveAll();

  [propget, helpstring("Determines whether the specified value intersects with any range in this set.")]
  HRESULT IntersectsWithValue([in] AGCEventID value,
    [out, retval] VARIANT_BOOL* pbIntersects);

  [propget, helpstring("Determines whether the specified range intersects with any range in this set.")]
  HRESULT IntersectsWithRangeValues([in] AGCEventID value1,
    [in] AGCEventID value2,
    [out, retval] VARIANT_BOOL* pbIntersects);

  [propget, helpstring("Determines whether the specified range intersects with any range in this set.")]
  HRESULT IntersectsWithRange([in] IAGCEventIDRange* pRange,
    [out, retval] VARIANT_BOOL* pbIntersects);

}; // End: interface IAGCEventIDRanges : IAGCCollection


/////////////////////////////////////////////////////////////////////////////
// The ITCCollection interface serves as the base interface from which most
// collection interfaces derive.
//
// *When To Implement*
//
// Implement the methods of this interface on any collection object that has
// the same collection semantics.
//
// *When To Use*
//
// Use this interface on a collection object.
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(B1935981-D27B-11d2-9646-00C04F68DEB0),
  helpstring("Base interface for most collection interfaces.")
]
interface ITCCollection : IDispatch
{
  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   pnCount - Address of a variable to receive the number of items in the
  // collection.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [propget, helpstring("Returns the number of items in the collection.")]
  HRESULT Count([out, retval] long* pnCount);

  ///////////////////////////////////////////////////////////////////////////
  // Remarks:
  // This property is provided for compatibility with VB, VBA, and VBScript.
  //
  // Parameters:
  //   ppunkEnum - Address of a variable to receive an enumerator object that
  // implements IEnumVARIANT.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [propget, hidden, restricted, id(DISPID_NEWENUM), helpstring("Returns an enumerator object that implements IEnumVARIANT.")]
  HRESULT _NewEnum([out, retval] IUnknown** ppunkEnum);

}; // End: interface ITCCollection : IDispatch


/////////////////////////////////////////////////////////////////////////////
// The ITCStrings interface exposes a collection of strings.
//
// *When To Implement*
//
// The Strings object implements this interface. Usually there is no reason
// to implement it on other objects.
//
// *When To Use*
//
// Use this interface on the Strings object to manage or query a collection
// of strings.
[
  object, dual, pointer_default(unique),
  uuid(C04322E0-CB3B-11d2-9646-00C04F68DEB0),
  helpstring("Interface to a collection of strings.")
]
interface ITCStrings : ITCCollection
{
  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   index - A pointer to a *VARIANT* of a type that can be coerced to
  // *VT_I4*. Specifies the 0-relative index of the item which is to be
  // retrieved.
  //   pbstr - Address of a variable to receive the specified string from the
  // collection.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  //   E_INVALIDARG - The specified index is out of range.
  [propget, id(DISPID_VALUE), helpstring("Returns a BSTR from the collection or NULL if the index is out of range. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] BSTR* pbstr);

  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   bstr - The string to be added to the end of the collection.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [helpstring("Adds the specified string to the collection.")]
  HRESULT Add([in] BSTR bstr);

  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   index - A pointer to a *VARIANT* of a type that can be coerced to
  // *VT_I4*. Specifies the 0-relative index of the item which is to be
  // removed.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_INVALIDARG - The specified index is out of range.
  [helpstring("Removes the specified string from the collection.")]
  HRESULT Remove([in] VARIANT* pvIndex);

  ///////////////////////////////////////////////////////////////////////////
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  [helpstring("Removes all strings from the collection.")]
  HRESULT RemoveAll();

  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   bstrDelimiter - The delimiter string which seperates the strings of
  // the /bstrStrings/ parameter.
  //   bstrStrings - The strings to be added to the end of the collection.
  // Each string is seperated by the delimiter specified by the
  // /bstrDelimiter/ parameter.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [helpstring("Adds the specified delimited strings to the collection.")]
  HRESULT AddDelimited([in] BSTR bstrDelimiter, [in] BSTR bstrStrings);

  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   bstrDelimiter - The delimiter string which is used to seperate the
  // strings returned in the /pbstrStrings/ parameter.
  //   pbstrStrings - Address of a variable to receive the entire array of
  // strings as a single string. Each string is seperated by the delimiter
  // specified by the /bstrDelimiter/ parameter.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [propget, helpstring("Returns the entire array of strings as a single string, delimited by the specified delimiter string.")]
  HRESULT DelimitedItems([in] BSTR bstrDelimiter, [out, retval] BSTR* pbstrStrings);

  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   pStrings - Another Strings object whose strings will be copied and
  // added to the end of this collection.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [helpstring("Adds the strings of the specified collection.")]
  HRESULT AddStrings([in] ITCStrings* pStrings);

};  // End: interface ITCStrings : IDispatch


/////////////////////////////////////////////////////////////////////////////
// ITCPropBagOnRegKey Interface
[
  object, dual, pointer_default(unique),
  uuid(8962E242-CD81-11d2-9646-00C04F68DEB0),
  helpstring("Interface to create a property bag on a registry key.")
]
interface ITCPropBagOnRegKey : IDispatch
{
  [helpstring("Creates or opens the specified registry key.")]
  HRESULT CreateKey([in] BSTR bstrRegKey, [in] VARIANT_BOOL bReadOnly);

  [helpstring("Opens the specified registry key.  Fails if the key does not exist.")]
  HRESULT OpenKey([in] BSTR bstrRegKey, [in] VARIANT_BOOL bReadOnly);

  [helpstring("Creates the object that is stored on the current registry key.")]
  HRESULT CreateObject([out, retval] IUnknown** ppunkObj);

  [helpstring("Creates the object, always on the local machine, that is stored on the current registry key.")]
  HRESULT CreateLocalObject([out, retval] IUnknown** ppunkObj);

  [helpstring("Creates the object, on the specified server, that is stored on the current registry key.")]
  HRESULT CreateRemoteObject([in] BSTR bstrServer,
    [out, retval] IUnknown** ppunkObj);

  [helpstring("Load the specified object from the values stored in the current registry key.")]
  HRESULT LoadObject([in] IUnknown* punkObj);

  [helpstring("Saves the specified object to the current registry key.")]
  HRESULT SaveObject([in] IUnknown* punkObj,
    [in, defaultvalue(0)] VARIANT_BOOL bClearDirty,
    [in, defaultvalue(-1)] VARIANT_BOOL bSaveAllProperties,
    [in, defaultvalue(-1)] VARIANT_BOOL bSaveCreationInfo);

  [propput, helpstring("Gets/sets the server on which the object stored on the current registry key will be created.")]
  HRESULT Server([in] BSTR bstrServer);
  [propget] HRESULT Server([out, retval] BSTR* pbstrServer);

  [propget, helpstring("Gets the string representation of the CLSID of the object stored on the current registry key.")]
  HRESULT ObjectCLSID([out, retval] BSTR* pbstrCLSID);

};  // End: interface ITCPropBagOnRegKey : IDispatch


/////////////////////////////////////////////////////////////////////////////
// The ITCSessionInfo interface exposes information about the connection of
// a session object.
[
  object, dual, pointer_default(unique),
  uuid(34E485E2-C7B7-11d2-85C9-00C04F68DEB0),
  helpstring("ITCSessionInfo Interface")
]
interface ITCSessionInfo : IDispatch
{
  ///////////////////////////////////////////////////////////////////////////
  // Parameter:
  //   pbstrUserName - Address of a variable to receive the name of the user
  // who created this session.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - An invalid pointer was specified.
  //   E_UNEXPECTED - Something unexpected occurred, such as an empty string
  // was specified.
  [propget, id(dispid_UserName), helpstring("Gets the user name of this session.")]
  HRESULT UserName([out, retval] BSTR* pbstrUserName);

  ///////////////////////////////////////////////////////////////////////////
  // Parameter:
  //   pbstrComputerName - Address of a variable to receive the computer name
  // from which this session was created.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - An invalid pointer was specified.
  //   E_UNEXPECTED - Something unexpected occurred, such as an empty string
  // was specified.
  [propget, id(dispid_ComputerName), helpstring("Gets the computer name of this session.")]
  HRESULT ComputerName([out, retval] BSTR* pbstrComputerName);

  ///////////////////////////////////////////////////////////////////////////
  // Parameter:
  //   bstrAppName - The name of the application from which this session was
  // created.
  //   pbstrAppName - Address of a variable to receive the name of the
  // application from which this session was created.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - An invalid pointer was specified.
  //   E_UNEXPECTED - Something unexpected occurred, such as an empty string
  // was specified.
  [propput, id(dispid_ApplicationName), helpstring("Gets/sets the application name of this session.")]
  HRESULT ApplicationName([in]BSTR bstrAppName);
  [propget]
  HRESULT ApplicationName([out, retval] BSTR* pbstrAppName);

  ///////////////////////////////////////////////////////////////////////////
  // Parameter:
  //   pdate - Address of a variable to receive the date and time, in
  // Coordinated Universal Time (UCT), that the session was created.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - An invalid pointer was specified.
  [propget, id(dispid_TimeCreated), helpstring("Returns the time the session was created.")]
  HRESULT TimeCreated([out, retval] DATE* pdate);

  ///////////////////////////////////////////////////////////////////////////
  // Parameter:
  //   pdate - Address of a variable to receive the duration of the session,
  // which is time it was created subtracted from the current time.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - An invalid pointer was specified.
  [propget, id(dispid_Duration), helpstring("Returns the duration of the session.")]
  HRESULT Duration([out, retval] DATE* pdate);

  ///////////////////////////////////////////////////////////////////////////
  // Parameter:
  //   pCookie - Address of a variable to receive an opaque value used to
  // uniquely identify this session within a process.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - An invalid pointer was specified.
  [propget, id(dispid_Cookie), helpstring("Uniquely identifies this session within a process.")]
  HRESULT Cookie([out, retval] long* pCookie);

}; // End: interface ITCSessionInfo : IDispatch


/////////////////////////////////////////////////////////////////////////////
// The ITCSessionInfos interface is used to enumerate a collection of
// Session Information Objects.
//
// Through this interface, the collection can be enumerated using the Count
// and Item properties. The Item property can be used to retrieve an item by
// its 1-based index.
//
// *When To Implement*
//
// Implement this object on a collection of session objects.
//
// *When To Use*
//
// Use ITCSessionInfos to enumerate a collection object provided by a
// session object. This allows a client to determine what other clients, if
// any, are also connected to the host of the session object. 
//
// See Also: ITCSessionInfo
[
  object, dual, pointer_default(unique),
  uuid(45038C6E-C7B7-11d2-85C9-00C04F68DEB0),
  helpstring("ITCSessionInfos interface")
]
interface ITCSessionInfos : ITCCollection
{
  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   index - A *VARIANT* which is coerced to type *VT_I4*. Specifies the
  // 0-relative index of the item which is to be retrieved.
  //   ppDriver - Address of an ITCSessionIdentity interface pointer that
  // receives the item specified by /index/.
  //
  // Return Value: One of the following values or an RPC error code if an
  // error occurred in the remoting layer:
  //
  //   S_OK - The function was successful.
  //   E_POINTER - The specified pointer is invalid.
  //   E_INVALIDARG - The specified index is out of range or is a
  // *VARIANT* type not supported by this interface.
  //
  // See Also: ITCSessionInfo
  [propget, id(DISPID_VALUE), helpstring("Returns a Session from the collection, or NULL if the session does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT index, [out, retval] ITCSessionInfo** ppSessionInfo);

};  // END: interface ITCSessionInfos : IAGCCollection


/////////////////////////////////////////////////////////////////////////////
// ITCCollectionPersistHelper Interface
[
  object, dual, pointer_default(unique),
  uuid(8962E24A-CD81-11d2-9646-00C04F68DEB0),
  helpstring("ITCCollectionPersistHelper interface")
]
interface ITCCollectionPersistHelper : IDispatch
{
  [propput, helpstring("Gets/sets the current thread priority.")]
  HRESULT Collection1([in] VARIANT* pvarSafeArray);
  [propget, id(dispid_Collection1)]
  HRESULT Collection1([out, retval] VARIANT* pvarSafeArray);

};  // END: interface ITCCollectionPersistHelper : IDispatch


/////////////////////////////////////////////////////////////////////////////
// ITCUtility Interface
[
  object, dual, pointer_default(unique),
  uuid(ADD577E2-ED3A-11d2-A50B-00C04F68DEB0),
  helpstring("ITCUtility interface")
]
interface ITCUtility : IDispatch
{
  [helpstring("Creates the specified object on the specified computer.")]
  HRESULT CreateObject([in] BSTR bstrProgID,
    [in, defaultvalue("")] BSTR bstrComputer, [out, retval] IUnknown** ppUnk);

  [helpstring("Create an object reference string.")]
  HRESULT ObjectReference([in] IUnknown* pUnk,
    [out, retval] BSTR* pbstrObjectReference);

  [helpstring("Sleeps for the specified number of milliseconds.")]
  HRESULT Sleep([in] long nDurationMS);

  [helpstring("Creates an object by binding the specified moniker display name.")]
  HRESULT GetObject([in] BSTR bstrMoniker,
    [in, defaultvalue(-1)] VARIANT_BOOL bAllowUI,
    [in, defaultvalue(-1)] long nTimeoutMS,
    [out, retval] IUnknown** ppUnk);

};  // END: interface ITCUtility : IDispatch


/////////////////////////////////////////////////////////////////////////////
// IAdminSessionHelper Interface
[
  object, dual, pointer_default(unique),
  uuid(143C0682-8688-421b-A269-9FD40F2AA19A),
  helpstring("IAdminSessionHelper interface")
]
interface IAdminSessionHelper : IDispatch
{
  [propget, helpstring("Indicates whether or not the Allegiance Game Server is currently running.")]
  HRESULT IsAllSrvRunning([out, retval] VARIANT_BOOL* pbIsRunning);

};  // END: interface IAdminSessionHelper : IDispatch


/////////////////////////////////////////////////////////////////////////////
// IAGCPrivate
[
  local, hidden, restricted, object, pointer_default(unique), nonextensible,
  uuid(4E001CF9-0D87-11d3-8B59-00C04F681633),
  helpstring("Internally-used interface on an AGC object.")
]
interface IAGCPrivate : IUnknown
{
  [helpstring("Get IGC Object Ptr.")]  
  void* GetIGCVoid();
}; // End: interface IAGCGamePrivate


/////////////////////////////////////////////////////////////////////////////
// IAGCCommon 
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(6EB476CE-17BC-11d3-8B61-00C04F681633),
  helpstring("IAGCCommon Interface")
]
interface IAGCCommon : IDispatch
{
//  [propget, id(dispid_UniqueID), helpstring("Every object in AGC has a unique id number and this is it.")]
//  HRESULT UniqueID([out, retval] AGCUniqueID* pUniqueID);

  [propget, id(dispid_Type), helpstring("Gets the implementation type ('agc', 'pig', 'admin').")]
  HRESULT Type([out, retval] BSTR* pbstrType);
}


/////////////////////////////////////////////////////////////////////////////
// The IAGCCollection interface serves as the base interface from which most
// collection interfaces derive.
//
// *When To Implement*
//
// Implement the methods of this interface on any collection object that has
// the same collection semantics.
//
// *When To Use*
//
// Use this interface on a collection object.
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(B8DB7D42-1E9C-11d3-8B63-00C04F681633),
  helpstring("Base interface for AGC collection interfaces.")
]
interface IAGCCollection : IAGCCommon
{
  ///////////////////////////////////////////////////////////////////////////
  // Parameters:
  //   pnCount - Address of a variable to receive the number of items in the
  // collection.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [propget, helpstring("Returns the number of items in the collection.")]
  HRESULT Count([out, retval] long* pnCount);

  ///////////////////////////////////////////////////////////////////////////
  // Remarks:
  // This property is provided for compatibility with VB, VBA, and VBScript.
  //
  // Parameters:
  //   ppunkEnum - Address of a variable to receive an enumerator object that
  // implements IEnumVARIANT.
  //
  // Return Value: One of the following results:
  //
  //   S_OK - The method completed successfully.
  //   E_POINTER - The specified pointer is invalid.
  [propget, hidden, restricted, id(DISPID_NEWENUM), helpstring("Returns an enumerator object that implements IEnumVARIANT.")]
  HRESULT _NewEnum([out, retval] IUnknown** ppunkEnum);

}; // End: interface IAGCCollection 


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(6967EA73-0A42-11D3-8B58-00C04F681633),
  helpstring("IAGCBase Interface")
]
interface IAGCBase : IAGCCommon
{
// FIX   [propget, id(), helpstring("")]
//    HRESULT Name([out, retval] BSTR* pbstrName);

  [propget, id(dispid_ObjectType), helpstring("This returns the type id of the object")]
  HRESULT ObjectType([out, retval] AGCObjectType* pObjectType);

  [propget, id(dispid_ObjectID), helpstring("This returns the id of the object in terms of its type; use UniqueID() for a completely unique id.")]
  HRESULT ObjectID([out, retval] AGCObjectID* pObjectID);

  [propget, id(dispid_GetMission), helpstring("Returns the AGC game in which this object lives.")]
  HRESULT Game([out, retval] IAGCGame** ppGame);

  [propget, id(dispid_BaseUniqueID), helpstring("Every object in AGC that has a base also has a unique id number and this is it.")]
  HRESULT UniqueID([out, retval] AGCUniqueID* pUniqueID);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(D64CB547-0A42-11D3-8B58-00C04F681633),
  helpstring("IAGCModel Interface")
]
interface IAGCModel : IAGCBase
{
  [propget, id(dispid_IsVisible), helpstring("")]
  HRESULT IsVisible([out, retval] VARIANT_BOOL* pbVisible);

  [propget, id(dispid_IsSeenBySide), helpstring("")]
  HRESULT IsSeenBySide([in] IAGCTeam* pTeam, [out, retval] VARIANT_BOOL* pbSeen);

  [propget, id(dispid_Position), helpstring("")]
  HRESULT Position([out, retval] IAGCVector** ppVector);

  [propget, id(dispid_Velocity), helpstring("")]
  HRESULT Velocity([out, retval] IAGCVector** ppVector);

  [propget, id(dispid_Orientation), helpstring("")]
  HRESULT Orientation([out, retval] IAGCOrientation** ppOrientation);

//
// TODO: implement this once Rotation is in:
//
//    [propget, id(dispid_Rotation), helpstring("")]
//    HRESULT Rotation([out, retval] IAGCRotation** ppRotation);

  [propget, id(dispid_Radius), helpstring("")]
  HRESULT Radius([out, retval] float* pfRadius);

  [propget, id(dispid_Team), helpstring("")]
  HRESULT Team([out, retval] IAGCTeam** ppTeam);

  [propget, id(dispid_Mass), helpstring("")]
  HRESULT Mass([out, retval] float* pfMass);

  [propget, id(dispid_Sector), helpstring("")]
  HRESULT Sector([out, retval] IAGCSector** ppSector);

  [propget, id(dispid_Signature), helpstring("")]
  HRESULT Signature([out, retval] float* pfSignature);

  [propget, id(DISPID_VALUE), helpstring("Gets the model's name")]
  HRESULT Name([out, retval] BSTR* pbstr);

/*

JOHN: these prototypes were in the initial idl draft you gave me, but I couldn't find
     an IGC counterpart for them.

     -Mark 2 of 3


  [propget, id(dispid_IsSelectable), helpstring("User can never pick the object")]
  HRESULT IsSelectable([out, retval] VARIANT_BOOL* pbSelectable);

  [propget, id(dispid_IsScanner), helpstring("Can see other objects")]
  HRESULT IsScanner([out, retval] VARIANT_BOOL* pbScanner);

  [propget, id(dispid_IsPredictable), helpstring("Send this object to a team when it is seen for the 1st time")]
  HRESULT IsPredictable([out, retval] VARIANT_BOOL* pbPredictable);

  [propget, id(dispid_IsScanRequired), helpstring("Need to track its visibility with regard to side")]
  HRESULT IsScanRequired([out, retval] VARIANT_BOOL* pbScanRequired);

  [propget, id(dispid_IsStatic), helpstring("Can not move")]
  HRESULT IsStatic([out, retval] VARIANT_BOOL* pbStatic);

  [propget, id(dispid_IsDamagable), helpstring("Can take damage")]
  HRESULT IsDamagable([out, retval] VARIANT_BOOL* pbDamagable);

  [propget, id(dispid_IsHitable), helpstring("Goes into the collision KD tree")]
  HRESULT IsHitable([out, retval] VARIANT_BOOL* pbHitable);
*/
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(9F04169B-FB9F-48c2-891B-DFC9B29E0493),
  helpstring("IAGCModels Interface")
]
interface IAGCModels : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns an AGCModel from the collection, or NULL if the item does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCModel** ppItemInterface);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, nonextensible, pointer_default(unique),
  uuid(5D48F7CC-1FA8-11d3-AF03-0000F810C3F4),
  helpstring("Properties of an object that is buyable.")
]
interface IAGCBuyable : IAGCBase
{
  [propget, id(DISPID_VALUE), helpstring("Gets the name of the object.")]
  HRESULT Name([out, retval] BSTR* pbstrName);

  [propget, id(dispid_Description), helpstring("Gets the description of the object.")]
  HRESULT Description([out, retval] BSTR* pbstrDescription);

  [propget, id(dispid_ModelName), helpstring("Gets the name of the model that buying this creates.")]
  HRESULT ModelName([out, retval] BSTR* pbstrModelName);

  [propget, id(dispid_Price), helpstring("Gets price of the object.")]
  HRESULT Price([out, retval] AGCMoney* pmoneyPrice);

  [propget, id(dispid_TimeToBuild), helpstring("Gets time to build the object.")]
  HRESULT TimeToBuild([out, retval] long* pnTimeToBuild);

  /* TODO: Implement these once we have an encapsulation for TechTreeBits
        virtual const TechTreeBitMask&  GetRequiredTechs(void) const = 0;
        virtual const TechTreeBitMask&  GetEffectTechs(void) const = 0;
   */

}; // End: interface IAGCBuyable : IAGCBase



/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(3C579426-2ED8-11d3-A51C-00C04F68DEB0),
  helpstring("Interface to an AGC Hull Type object.")
]
interface IAGCHullType : IAGCBuyable
{
  [propget, id(dispid_Length), helpstring("Gets the Length.")]
  HRESULT Length([out, retval] float* pfLength);

  [propget, id(dispid_MaxSpeed), helpstring("Gets the MaxSpeed.")]
  HRESULT MaxSpeed([out, retval] float* pfMaxSpeed);

  [propget, id(dispid_MaxTurnRate), helpstring("Gets the MaxTurnRate.")]
  HRESULT MaxTurnRate([in] AGCAxis eAxis, [out, retval] float* pfMaxTurnRate);

  [propget, id(dispid_TurnTorque), helpstring("Gets the TurnTorque.")]
  HRESULT TurnTorque([in] AGCAxis eAxis, [out, retval] float* pfTurnTorque);

  [propget, id(dispid_Thrust), helpstring("Gets the Thrust.")]
  HRESULT Thrust([out, retval] float* pfThrust);

  [propget, id(dispid_SideMultiplier), helpstring("Gets the SideMultiplier.")]
  HRESULT SideMultiplier([out, retval] float* pfSideMultiplier);

  [propget, id(dispid_BackMultiplier), helpstring("Gets the BackMultiplier.")]
  HRESULT BackMultiplier([out, retval] float* pfBackMultiplier);

  [propget, id(dispid_ScannerRange), helpstring("Gets the ScannerRange.")]
  HRESULT ScannerRange([out, retval] float* pfScannerRange);

  [propget, id(dispid_MaxEnergy), helpstring("Gets the MaxEnergy.")]
  HRESULT MaxEnergy([out, retval] float* pfMaxEnergy);

  [propget, id(dispid_RechargeRate), helpstring("Gets the RechargeRate.")]
  HRESULT RechargeRate([out, retval] float* pfRechargeRate);

  [propget, id(dispid_HitPoints), helpstring("Gets the HitPoints.")]
  HRESULT HitPoints([out, retval] AGCHitPoints* pHitPoints);

  [propget, id(dispid_PartMask), helpstring("Gets the PartMask.")]
  HRESULT PartMask([in] AGCEquipmentType et, [in] AGCMount mountID,
    [out, retval] AGCPartMask* pPartMask);

  [propget, id(dispid_MaxWeapons), helpstring("Gets the MaxWeapons.")]
  HRESULT MaxWeapons([out, retval] AGCMount* pMaxWeapons);

  [propget, id(dispid_MaxFixedWeapons), helpstring("Gets the MaxFixedWeapons.")]
  HRESULT MaxFixedWeapons([out, retval] AGCMount* pMaxFixedWeapons);

//  [propget, id(dispid_CanMount), helpstring("Gets the CanMount.")]
//  HRESULT CanMount([in] IAGCPartType* pPartType, [in] AGCMount mountID,
//    [out, retval] VARIANT_BOOL* pbCanMount);

  [propget, id(dispid_Mass), helpstring("Gets the Mass.")]
  HRESULT Mass([out, retval] float* pfMass);

  [propget, id(dispid_Signature), helpstring("Gets the Signature.")]
  HRESULT Signature([out, retval] float* pfSignature);

  [propget, id(dispid_Capabilities), helpstring("Gets the Capabilities.")]
  HRESULT Capabilities([out, retval] AGCHullAbilityBitMask* phabmCapabilities);

  [propget, id(dispid_HasCapability), helpstring("Determines if the object has the specified capabilities..")]
  HRESULT HasCapability([in] AGCHullAbilityBitMask habm,
    [out, retval] VARIANT_BOOL* pbHasCapability);

  [propget, id(dispid_MaxAmmo), helpstring("Gets the MaxAmmo.")]
  HRESULT MaxAmmo([out, retval] short* pnMaxAmmo);

  [propget, id(dispid_MaxFuel), helpstring("Gets the MaxFuel.")]
  HRESULT MaxFuel([out, retval] float* pfMaxFuel);

}; // End: interface IAGCHullType : IAGCBuyable


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(3AFF440E-0E49-11d3-8B59-00C04F681633)
]
interface IAGCTreasure : IAGCModel
{
  [propget, id(dispid_Type), helpstring("")]
  HRESULT Type([out, retval] AGCTreasureType* peType);

  [propget, id(dispid_Amount), helpstring("")]
  HRESULT Amount([out, retval] short* pnAmount);

// FIX: implment once IAGCBuyable exists  [propget, id(dispid_Buyable), helpstring("Gets the buyable object that this treasure represents.")]
//  HRESULT Buyable([out, retval] IAGCBuyable** ppBuyable);

}; // interface IAGCTreasure : IAGCModel


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(DA3A2550-3997-11d3-A51D-00C04F68DEB0),
  helpstring("IAGCTreasures Interface")
]
interface IAGCTreasures : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns an AGCTreasure from the collection, or NULL if the game does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCTreasure** ppItemInterface);

}; // End: interface IAGCTreasures : IAGCCollection


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(DF2F4B4E-0A42-11D3-8B58-00C04F681633),
  helpstring("IAGCDamage Interface")
]
interface IAGCDamage : IAGCModel
{
  [propget, id(dispid_Fraction), helpstring("")]
  HRESULT Fraction([out, retval] float* pfFraction);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(E9004E70-0A42-11D3-8B58-00C04F681633),
  helpstring("IAGCScanner Interface")
]
interface IAGCScanner : IAGCDamage
{
  [propget, id(dispid_InScannerRange), helpstring("")]
  HRESULT InScannerRange([in] IAGCModel* pModel,
    [out, retval] VARIANT_BOOL* pbInScannerRange);

  [propget, id(dispid_CanSee), helpstring("")]
  HRESULT CanSee([in] IAGCModel* pModel,
    [out, retval] VARIANT_BOOL* pbCanSee);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(2A91FB76-71BA-4f1a-B1E8-A457A592854D),
  helpstring("IAGCProbe Interface")
]
interface IAGCProbe : IAGCScanner
{
// Implement when IAGCProjectileType is implemented
//  [propget, id(dispid_ProjectileType), helpstring("Gets the type of projectiles fired, if any.")]
//  HRESULT ProjectileType([out, retval] IAGCProjectileType** ppType);

  [propget, id(dispid_EmissionPoint), helpstring("Gets the point of weapon fire emission.")]
  HRESULT EmissionPoint([out, retval] IAGCVector** ppEmissionPoint);

  [propget, id(dispid_Lifespan), helpstring("Gets the lifespan.")]
  HRESULT Lifespan([out, retval] float* pfLifespan);

  [propget, id(dispid_DtBurst), helpstring("Gets the weapon burst rate(?).")]
  HRESULT DtBurst([out, retval] float* pfDtBurst);

  [propget, id(dispid_Accuracy), helpstring("Gets the weapon firing accuracy.")]
  HRESULT Accuracy([out, retval] float* pfAccuracy);

  [propget, id(dispid_IsRipcord), helpstring("Gets the indicator of the probe being a ripcord destination.")]
  HRESULT IsRipcord([out, retval] VARIANT_BOOL* pbIsRipcord);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(8A003DBD-93E8-4922-AC4B-7AF44291A89D),
  helpstring("IAGCProbes Interface")
]
interface IAGCProbes : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns an AGCProbe from the collection, or NULL if the item does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCProbe** ppItemInterface);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(E6D48FB7-0A41-11D3-8B58-00C04F681633),
  helpstring("IAGCGame Interface")
]
interface IAGCGame : IAGCCommon
{
  [propget, id(DISPID_VALUE), helpstring("Gets the game's name")]
  HRESULT Name([out, retval] BSTR* pbstr);

  [propget, id(dispid_Sectors), helpstring("Gets the collection of sectors in the game.")]
  HRESULT Sectors([out, retval] IAGCSectors** ppAGCSectors);

  [propget, id(dispid_Teams), helpstring("Gets the collection of teams in the game.")]
  HRESULT Teams([out, retval] IAGCTeams** ppAGCTeams);

  [propget, id(dispid_LookupShip), helpstring("Gets the Ship associated with specified AGC ID.")]
  HRESULT LookupShip([in] AGCUniqueID idAGC, [out, retval] IAGCShip** ppAGCObject);

  [propget, id(dispid_Ships), helpstring("Gets the collection of the ships in the game.")]
  HRESULT Ships([out, retval] IAGCShips** ppShips);

  [propget, id(dispid_Alephs), helpstring("Gets the collection of alephs in the game.")]
  HRESULT Alephs([out, retval] IAGCAlephs** ppAlephs);

  [propget, id(dispid_Asteroids), helpstring("Gets the collection of asteroids in the game.")]
  HRESULT Asteroids([out, retval] IAGCAsteroids** ppAsteroids);

  [propget, id(dispid_GameParameters), helpstring("Gets the parameters used to create the game.")]
  HRESULT GameParameters([out, retval] IAGCGameParameters** ppParams);

  [propget, id(dispid_GameID), helpstring("Gets unique mission id.")]
  HRESULT GameID([out, retval] AGCGameID* pMissionId);

  [propget, id(dispid_LookupTeam), helpstring("Gets the team associated with specified AGC ID.")]
  HRESULT LookupTeam([in] AGCObjectID idAGC, [out, retval] IAGCTeam** ppAGCObject);

  [helpstring("Sends the specified chat text to everyone in the Game.")]
  HRESULT SendChat([in] BSTR bstrText, [in, defaultvalue(-1)] AGCSoundID idSound);

  [helpstring("Sends the specified command to everyone in the Game.")]
  HRESULT SendCommand([in] BSTR bstrCommand, [in] IAGCModel* pModelTarget,
    [in, defaultvalue(-1)] AGCSoundID idSound);

  [propget, id(dispid_GameStage), helpstring("Gets the stage of the game.")]
  HRESULT GameStage([out, retval] AGCGameStage* pStage);

  [propget, id(dispid_Probes), helpstring("Gets the collection of probes in the game.")]
  HRESULT Probes([out, retval] IAGCProbes** ppProbes);

  [propget, id(dispid_Buoys), helpstring("Gets the collection of buoys in the game.")]
  HRESULT Buoys([out, retval] IAGCModels** ppBuoys);

  [propget, id(dispid_Treasures), helpstring("Gets the collection of treasures in the game.")]
  HRESULT Treasures([out, retval] IAGCModels** ppTreasures);

  [propget, id(dispid_Mines), helpstring("Gets the collection of mines in the game.")]
  HRESULT Mines([out, retval] IAGCModels** ppMines);

  [propget, id(dispid_ReplayCount), helpstring("Gets the number of times this game has been 'reused'.")]
  HRESULT ReplayCount([out, retval] short* pnReplays);

  [propget, id(dispid_ContextName), helpstring("Gets a string that uniquely identifies the game context, within the game server.")]
  HRESULT ContextName([out, retval] BSTR* pbstrContextName);

}; // End: interface IAGCGame : IAGCCommon


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(4F860D30-0A42-11D3-8B58-00C04F681633),
  helpstring("IAGCShip Interface")
]
interface IAGCShip : IAGCScanner
{
  [propput, helpstring("Amount of ammo the ship has.")]
  HRESULT Ammo([in] short Val);
  [propget, id(dispid_Ammo)] 
  HRESULT Ammo([out, retval] short* pVal);

  [propput, helpstring("Amount of fuel the ship has.")]
  HRESULT Fuel([in] float Val);
  [propget, id(dispid_Fuel)] 
  HRESULT Fuel([out, retval] float* pVal);

  [propput, helpstring("Amount of energy the ship has.")]
  HRESULT Energy([in] float Val);
  [propget, id(dispid_Energy)] 
  HRESULT Energy([out, retval] float* pVal);

  [propput, helpstring("Ship's Wing ID.")]
  HRESULT WingID([in] short Val);
  [propget, id(dispid_WingID)] 
  HRESULT WingID([out, retval] short* pVal);

  [helpstring("Sends the specified chat text to the ship.")]
  HRESULT SendChat([in] BSTR bstrText, [in, defaultvalue(-1)] AGCSoundID idSound);

  [helpstring("Sends the specified command to the ship.")]
  HRESULT SendCommand([in] BSTR bstrCommand, [in] IAGCModel* pModelTarget,
    [in, defaultvalue(-1)] AGCSoundID idSound);

  [propput, helpstring("Gets/sets the AutoDonate ship.")]
  HRESULT AutoDonate([in] IAGCShip* pShip);
  [propget, id(dispid_AutoDonate)]
  HRESULT AutoDonate([out, retval] IAGCShip** ppShip);

  [propput, helpstring("Gets/sets the ship's ShieldFraction")]
  HRESULT ShieldFraction([in] float pVal);
  [propget, id(dispid_ShieldFraction)]
  HRESULT ShieldFraction([out, retval] float* pVal);

  [propget, id(dispid_HullType), helpstring("Gets the ship's Hull type.")]
  HRESULT HullType([out, retval] IAGCHullType** ppHullType);

  [propget, id(dispid_BaseHullType), helpstring("Gets the ship's base hull type.")]
  HRESULT BaseHullType([out, retval] IAGCHullType** ppHullType);

}; // End: interface IAGCShip : IAGCScanner


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(EDB8C96C-1EBE-11d3-8B63-00C04F681633),
  helpstring("IAGCShips Interface")
]
interface IAGCShips : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns a AGCShip from the collection, or NULL if the item does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCShip** ppItemInterface);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(C9438C34-026A-11D3-8B55-00C04F681633),
  helpstring("IAGCStation Interface")
]
interface IAGCStation : IAGCScanner
{
  [propput, helpstring("Gets/sets the station's ShieldFraction")]
  HRESULT ShieldFraction([in] float pVal);
  [propget, id(dispid_ShieldFraction)]
  HRESULT ShieldFraction([out, retval] float* pVal);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(6EA96980-0272-11D3-8B55-00C04F681633),
  helpstring("IAGCStations Interface")
]
interface IAGCStations : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns a AGCStation from the collection, or NULL if the item does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCStation** ppItemInterface);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(0AFEC67E-0325-11D3-8B57-00C04F681633),
  helpstring("IAGCAleph Interface")
]
interface IAGCAleph : IAGCModel
{
  [propget, helpstring("Gets the destination aleph.")]
  HRESULT Destination([out, retval] IAGCAleph** ppDestination);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(88400BB3-026B-11D3-8B55-00C04F681633),
  helpstring("IAGCAlephs Interface")
]
interface IAGCAlephs : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns a AGCAleph from the collection, or NULL if the AGCAleph does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCAleph** ppAGCAleph);

}; // End: interface IAGCAlephs : IAGCCollection


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(1FC0E193-EBA5-11D2-8B4B-00C04F681633),
  helpstring("IAGCSector Interface")
]
interface IAGCSector : IAGCBase
{
  [propget, id(DISPID_VALUE), helpstring("Gets the AGCSector's name")]
  HRESULT Name([out, retval] BSTR* pbstr);
//    [propput]
//    HRESULT Name([in] BSTR bstr);

  [propget, id(dispid_Stations), helpstring("Gets the collection of stations in the sector.")]
  HRESULT Stations([out, retval] IAGCStations** ppStations);

  [propget, id(dispid_Ships), helpstring("Gets the collection of ships in the sector.")]
  HRESULT Ships([out, retval] IAGCShips** ppShips);

  [propget, id(dispid_Alephs), helpstring("Gets the collection of alephs in the sector.")]
  HRESULT Alephs([out, retval] IAGCAlephs** ppAlephs);

  [propget, id(dispid_Asteroids), helpstring("Gets the collection of asteroids in the sector.")]
  HRESULT Asteroids([out, retval] IAGCAsteroids** ppAsteroids);

  [helpstring("Sends the specified chat text to everyone in the Sector.")]
  HRESULT SendChat([in] BSTR bstrText,
    [in, defaultvalue(0)] VARIANT_BOOL bIncludeEnemies,
    [in, defaultvalue(-1)] AGCSoundID idSound);

  [helpstring("Sends the specified command to everyone in the Sector.")]
  HRESULT SendCommand([in] BSTR bstrCommand, [in] IAGCModel* pModelTarget,
    [in, defaultvalue(0)] VARIANT_BOOL bIncludeEnemies,
    [in, defaultvalue(-1)] AGCSoundID idSound);

  [propget, id(dispid_ScreenX), helpstring("Gets sector's X position relative to other sectors.  This is used in the sector overview display.  This value never changes.")]
  HRESULT ScreenX([out, retval] float * pVal);

  [propget, id(dispid_ScreenY), helpstring("Gets sector's Y position relative to other sectors.  This is used in the sector overview display.  This value never changes.")]
  HRESULT ScreenY([out, retval] float * pVal);

  [propget, id(dispid_Mines), helpstring("Gets the collection of mines in the sector.")]
  HRESULT Mines([out, retval] IAGCModels** ppMines);

  [propget, id(dispid_Missiles), helpstring("Gets the collection of missiles in the sector.")]
  HRESULT Missiles([out, retval] IAGCModels** ppMissiles);

  [propget, id(dispid_Probes), helpstring("Gets the collection of probes in the sector.")]
  HRESULT Probes([out, retval] IAGCProbes** ppProbes);

  [propget, id(dispid_Models), helpstring("Gets the collection of models in the sector.")]
  HRESULT Models([out, retval] IAGCModels** ppModels);

  [propget, id(dispid_SelectableModels), helpstring("Gets the collection of selectable models in the sector.")]
  HRESULT SelectableModels([out, retval] IAGCModels** ppModels);

  [propget, id(dispid_Treasures), helpstring("Gets the collection of treasures in the sector.")]
  HRESULT Treasures([out, retval] IAGCModels** ppTreasures);

}; // End: interface IAGCSector : IAGCBase


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(338DA8FF-EBA5-11D2-8B4B-00C04F681633),
  helpstring("IAGCSectors Interface")
]
interface IAGCSectors : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns a AGCSector from the collection, or NULL if the sector does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCSector** ppItemInterface);
};


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(4214FD6F-EBA5-11D2-8B4B-00C04F681633),
  helpstring("IAGCTeam Interface")
]
interface IAGCTeam : IAGCBase
{
  [propget, id(DISPID_VALUE), helpstring("Gets the team's name")]
  HRESULT Name([out, retval] BSTR* pbstr);
//    [propput]
//    HRESULT Name([in] BSTR bstr);

  [propget, id(dispid_Stations), helpstring("Returns a collection of stations that belong to the team.")]
  HRESULT Stations([out, retval] IAGCStations** ppStations);

  [propget, id(dispid_Ships), helpstring("Returns a Ships collection of the ships in the team.")]
  HRESULT Ships([out, retval] IAGCShips** ppShips);

  [propget, id(dispid_Civ), helpstring("Returns name of civ for team.")]
  HRESULT Civ([out, retval] BSTR* pbstr);

  [helpstring("Sends the specified chat text to everyone on the Team.")]
  HRESULT SendChat([in] BSTR bstrText,
    [in, defaultvalue(-1)] short idWing,
    [in, defaultvalue(-1)] AGCSoundID idSound);

  [helpstring("Sends the specified command to everyone on the Team.")]
  HRESULT SendCommand([in] BSTR bstrCommand, [in] IAGCModel* pModelTarget,
    [in, defaultvalue(-1)] short idWing,
    [in, defaultvalue(-1)] AGCSoundID idSound);

//    [propget, id(dispid_TeamOwner), helpstring("Returns the Ship of the team owner.")]
//    HRESULT TeamOwner([out, retval] IAGCShip** ppShip);

}; // End: interface IAGCTeam : IAGCBase


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(65E8F3E4-EBA5-11D2-8B4B-00C04F681633),
  helpstring("IAGCTeams Interface")
]
interface IAGCTeams : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns a AGCTeam from the collection, or NULL if the game does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCTeam** ppItemInterface);

}; // End: interface IAGCTeams : IAGCCollection


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(8B4100A0-38B7-11d3-A51D-00C04F68DEB0),
  helpstring("IAGCAsteroid Interface")
]
interface IAGCAsteroid : IAGCDamage
{
  [propget, helpstring("Gets the amount of ore remaining on the asteroid.")]
  HRESULT Ore([out, retval] float* pfOre);

  [propget, id(dispid_Capabilities), helpstring("Gets the Capabilities bit mask of the object.")]
  HRESULT Capabilities([out, retval] AGCAsteroidAbilityBitMask* paabmCapabilities);

  [propget, id(dispid_HasCapability), helpstring("Determines if the object has the specified capabilities.")]
  HRESULT HasCapability([in] AGCAsteroidAbilityBitMask aabm,
    [out, retval] VARIANT_BOOL* pbHasCapability);

}; // End: interface IAGCAsteroid : IAGCDamage


/////////////////////////////////////////////////////////////////////////////
[
  object, dual, pointer_default(unique), nonextensible,
  uuid(A61112C6-38B7-11d3-A51D-00C04F68DEB0),
  helpstring("IAGCAsteroids Interface")
]
interface IAGCAsteroids : IAGCCollection
{
  [propget, id(DISPID_VALUE), helpstring("Returns an AGCAsteroid from the collection, or NULL if the game does not exist. Takes an argument, index, which must be the index into the collection.")]
  HRESULT Item([in] VARIANT* pvIndex, [out, retval] IAGCAsteroid** ppItem);

}; // End: interface IAGCAsteroids : IAGCCollection


/////////////////////////////////////////////////////////////////////////
// Smart Pointer Declarations

cpp_quote("#ifdef __cplusplus")
cpp_quote("  extern \"C++\"")
cpp_quote("  {")
cpp_quote("    /////////////////////////////////////////////////////////////////////////")
cpp_quote("    // Smart Pointer Declarations")
cpp_quote("")
cpp_quote("    #if _MSC_VER >= 1100")
cpp_quote("")
cpp_quote("      #include <comdef.h>")
cpp_quote("")
cpp_quote("      #ifndef TC_COM_SMARTPTR_TYPEDEF")
cpp_quote("        #define TC_COM_SMARTPTR_TYPEDEF(Interface) \\")
cpp_quote("          _COM_SMARTPTR_TYPEDEF(Interface, __uuidof(Interface))")
cpp_quote("      #endif // TC_COM_SMARTPTR_TYPEDEF")
cpp_quote("")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventSink);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventSinkSynchronous);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCDebugHook);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCGlobal);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCVector);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCVectorPrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCOrientation);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCOrientationPrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEvent);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventCreate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCGameParameters);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCCommand);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCCommandPrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCVersionInfo);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCDBParams);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventLogger);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventLoggerHook);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventLoggerPrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCRangePrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCRangesPrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventIDRange);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCEventIDRanges);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(ITCStrings);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(ITCPropBagOnRegKey);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(ITCSessionInfo);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(ITCSessionInfos);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(ITCCollectionPersistHelper);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(ITCUtility);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAdminSessionHelper);")
cpp_quote("")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCPrivate);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCCommon);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCCollection);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCBase);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCModel);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCModels);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCBuyable);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCHullType);")
//cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCHullTypes);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCTreasure);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCTreasures);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCDamage);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCScanner);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCProbe);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCProbes);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCGame);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCShip);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCShips);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCStation);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCStations);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCAleph);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCAlephs);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCSector);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCSectors);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCTeam);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCTeams);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCAsteroid);")
cpp_quote("      TC_COM_SMARTPTR_TYPEDEF(IAGCAsteroids);")
cpp_quote("")
cpp_quote("    #endif // _MSC_VER >= 1100")
cpp_quote("")
cpp_quote("")
cpp_quote("    #if defined(AGC_HOST) || defined(AGC_MODULE)")
cpp_quote("")
cpp_quote("      #include \"AGCModule.h\"")
cpp_quote("")
cpp_quote("      extern CAGCModule _AGCModule;")
cpp_quote("")
cpp_quote("      #if defined(AGC_MODULE)")
cpp_quote("")
cpp_quote("        inline IAGCGlobalPtr GetAGCGlobal()")
cpp_quote("        {")
cpp_quote("          return _AGCModule.GetAGCGlobal();")
cpp_quote("        }")
cpp_quote("")
cpp_quote("      #else // AGC_MODULE")
cpp_quote("")
cpp_quote("        inline IAGCGlobal* GetAGCGlobal()")
cpp_quote("        {")
cpp_quote("          return _AGCModule.GetAGCGlobal();")
cpp_quote("        }")
cpp_quote("")
cpp_quote("      #endif // defined(AGC_MODULE)")
cpp_quote("")
cpp_quote("    #endif // defined(AGC_HOST) || defined(AGC_MODULE)")
cpp_quote("")
cpp_quote("  } // extern \"C++\"")
cpp_quote("#endif // __cplusplus")
cpp_quote("")

