#pragma once

// BT - STEAM

// FileHashTable provides an internal verification of the artwork files to prevent tampering. The .cpp file is generated from ArtworkHashGenerator automatically when you build it. 
// You must rebuild ArtworkHashGenerator if you modify anything under the Artwork folder or it may be rejected by Allegiance when it runs. 

class FileHashTable
{
private:
	TVector<FileHash, DefaultEquals, DefaultCompare> m_filehashes;


public:
	FileHashTable(); // The implementation of this will be autogenerated by ArtworkHashGenerator as part of the build for that application..

	// If no hash exists for a file, then this always returns true.
	inline bool IsHashCorrect(ZString filename, TRef<ZFile> &file)
	{
		ZString targetFilename = filename;

		if (targetFilename.ReverseFind('\\') > -1)
			targetFilename = targetFilename.RightOf(targetFilename.ReverseFind('\\') + 1);

		if (targetFilename.ReverseFind('/') > -1)
			targetFilename = targetFilename.RightOf(targetFilename.ReverseFind('/') + 1);

		FileHash target(targetFilename, "");

		int index = m_filehashes.Find(target);
		if (index == -1)
			return true;

		ZDebugOutput("FileHashTable::IsHashCorrect(): Checking filehash on: " + filename + "\n");

		FileHash check = m_filehashes.Get(index);

		return check.m_hash == file->GetSha1Hash();
	}

	inline bool DoesFileHaveHash(ZString filename)
	{
		ZString targetFilename = filename;

		if (targetFilename.ReverseFind('\\') > -1)
			targetFilename = targetFilename.RightOf(targetFilename.ReverseFind('\\') + 1);

		if (targetFilename.ReverseFind('/') > -1)
			targetFilename = targetFilename.RightOf(targetFilename.ReverseFind('/') + 1);

		FileHash target(targetFilename, "");

		return m_filehashes.Find(target) > -1;
	}

};